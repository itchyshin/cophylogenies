---
title: "A Broadscale Test of Host-Symbiont Cophylogeny Reveals Key Drivers of Phylogenetic Congruence"
author: "Alexander Hayward, Robert Poulin & Shinichi Nakagawa"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_download: true
    code_folding: hide
    depth: 4
    number_sections: no
    theme:  cosmo # “default”, “cerulean”, “journal”, “flatly”, “darkly”, “readable”, “spacelab”, “united”, “cosmo”, “lumen”, “paper”, “sandstone”, “simplex”, “yeti”
    toc: yes
    toc_float: yes
    toc_depth: 4
  pdf_document:
    toc: yes
subtitle: Supplementary Material
bibliography: references.bib
#biblio-style: "apalike"
csl: ecol_lett.csl
link-citations: yes
#always_allow_html: true
---

```{r setup, include = FALSE}
#kniter seetting
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE, # no warnings
cache = TRUE,# Cacheing to save time when kniting
tidy = TRUE
#fig.width = 9
)

# clearning up
rm(list=ls())
```

## Setups

### Loading packages and custom functions

```{r}
# loading packages
# devtools::install_github("thomasp85/patchwork")
pacman::p_load(tidyverse, # tidy family and related pacakges below
               kableExtra, 
               gridExtra, # may not use this
               purrr,
               magrittr, # extending piping
               pander,   # nice tables
               metafor,  # package for meta-analysis
               MCMCglmm,  # Bayeisan mixed model package
               ggbeeswarm, # making bee-swarm plots possible
               plotly,     # interactive plots using ggplot2
               MuMIn,  # multi-model inference
               lme4,   # lmm & glmm (models)
               broom.mixed, # getting estimates from lmer + glmer objects
               performance, # getting R2 from lmer + glmer objects
               png,         # reading png files
               grid,        # graphic layout manipulation
               patchwork,   # putting ggplots together - you need to install via devtool
               here         # making reading files easy
               #lmerTest,   # more functions for lme4
               #mi,      # missing data analysis
               #betareg   # dependence of the above
)
```

#### Custom functions

We have 5 custom functions named : `p_to_Zr()`,`I2()`, `R2()`, `get_est()`, `get_pred()`, and `cont_gen()`, all of which are used later (see below for their functionality) and the code is included here. 

```{r}
# coustm functions

#' Title: getting Zr and its sampling variance from p value 
#'
#' @param data: data frame 
#' @param pval: p value
#' @param N: sample size (N: the number of species ) and the degrees of freedom df = N - 2
#'
#' @return
#' @export
#'
#' @examples
p_to_Zr <- function(data, pval, N) {
  
  # turning them into strings
  pval <- data[[deparse(substitute(pval))]]
  N <- data[[deparse(substitute(N))]]
  
  # getting t values 
  tval<- -qt(pval, N - 2) 
  rval <- tval / sqrt((tval^2) + (N - 2))
  
  # define Zr function
  # Zr <- 0.5*(log(1 + rval) - log(1 - rval)); the same as below
  # r <-tanh(Zr) # turning Zr to r
  Zr <- atanh(rval)
  
  # getting Var(Zr)
  VZr <- 1 / (N - 3)
  
  # putting all together
  Zrs <- tibble(rval, Zr, VZr)
  data <- bind_cols(data, Zrs)
}

# coverting back Zr to r
# Just use "psych" pacakge - fisherz2r(z) - <http://personality-project.org/r/psych/help/fisherz.html>
# or this will do : r to Zr is tanh(r)!!

# Functions for processing


# General modeling functions 
# Functions for I2

#' Title Function to obtain total and separate I2 from multilevel-meta-analytic model
#'
#' @param model 
#' @param method 
#'
#' @return
#' @export
#'
#' @examples
I2 <- function(model, method = c("Wolfgang", "Shinichi")){
  
  ## evaluate choices
  method <- match.arg(method)
  
  # Wolfgang's method
  if(method == "Wolfgang"){
    W <- solve(model$V) 
    X <- model.matrix(model)
    P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
    I2_total <- sum(model$sigma2) / (sum(model$sigma2) + (model$k - model$p) / sum(diag(P)))
    I2_each  <- model$sigma2 / (sum(model$sigma2) + (model$k - model$p) / sum(diag(P)))
    names(I2_each) = paste0("I2_", model$s.names)
    
    # putting all together
    I2s <- c(I2_total = I2_total, I2_each)
    
    # or my way
  } else {
    # sigma2_v = typical sampling error variance
    sigma2_v <- sum(1/model$vi) * (model$k-1) / (sum(1/model$vi)^2 - sum((1/model$vi)^2)) 
    I2_total <- sum(model$sigma2) / (sum(model$sigma2) + sigma2_v) #s^2_t = total variance
    I2_each  <- model$sigma2 / (sum(model$sigma2) + sigma2_v)
    names(I2_each) = paste0("I2_", model$s.names)
    
    # putting all together
    I2s <- c(I2_total = I2_total, I2_each)
  }
  return(I2s)
}

# test <- dataset$fit4.1[[3]]
# I2(test, method = "Wolfgang")
# I2(test, method = "Shinichi")


#' Title: R2 based on Nakagawa & Schielzeth 2013
#'
#' @param model 
#'
#' @return
#' @export
#'
#' @examples
R2 <- function(model){
  warning("Conditional R2 is not meaningful and the same as marginal R2\n")
  
  # fixed effect variance
  fix <- var(as.numeric(as.vector(model$b) %*% t(as.matrix(model$X))))
  
  # marginal
  R2m <- fix / (fix + sum(model$sigma2))
  R2
  #Rm <- round(100*R2m, 3)
  
  # conditional
  R2c <- (fix + sum(model$sigma2) - model$sigma2[length(model$sigma2)]) / 
    (fix + sum(model$sigma2))
  
  R2s <- c(R2_marginal = R2m, R2_coditional = R2c)
  return(R2s)
}


#' Title: the function to get estimates from rma objects (metafor)
#'
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_est <- function (model, mod = " ") {
  
  name <- as.factor(str_replace(row.names(model$beta), mod, ""))
  estimate <- as.numeric(model$beta)
  lowerCL <- model$ci.lb
  upperCL <- model$ci.ub 
  
  table <- tibble(name = name, estimate = estimate, lowerCL = lowerCL, upperCL = upperCL)
}


#' Title: the function to get prediction intervals (crediblity intervals) from rma objects (metafor)
#'
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_pred <- function (model, mod = " ") {
  name <- as.factor(str_replace(row.names(model$beta), mod, ""))
  len <- length(name)
  
  if(len != 1){
  newdata <- matrix(NA, ncol = len, nrow = len)
  for(i in 1:len) {
    # getting the position of unique case from X (design matrix)
    pos <- which(model$X[,i] == 1)[[1]]
    newdata[, i] <- model$X[pos,]
    }
  pred <- predict.rma(model, newmods = newdata)
  }
  else {
    pred <- predict.rma(model)
    }
  lowerPR <- pred$cr.lb
  upperPR <- pred$cr.ub 
  
  table <- tibble(name = name, lowerPR = lowerPR, upperPR = upperPR)
}

#Here are links for how to do confidence regions for rma.mv regression lines
#https://www.rdocumentation.org/packages/metafor/versions/1.9-9/topics/predict.rma
#https://stackoverflow.com/questions/50804464/out-of-sample-prediction-for-rma-object-in-metafor


#' Title: Contrast name geneator
#'
#' @param name: a vector of character strings
cont_gen <- function (name) {
  combination <- combn(name,2)
  name_dat <- t(combination)
  names <- paste(name_dat[ ,1], name_dat[, 2], sep = "-")
  return(names)
}
```


## Appendix S1: Supplementary Methods

### Supplementary information for the literature search

#### Table S1.1
Citations for papers describing the main methods of cophylogeny analysis, based on a *Google Scholar* search conducted on 4th July 2019. Although the paper describing Brooks parsimony analysis has more citations than that describing the Parafit method, relatively few citations correspond to actual cophylogenetic analyses employing the approach, *versus* methodological discussion.

```{r}
# getting the data and formating some variables (turning chraracter vectors to factors)
read_csv(here("data/lit_search.csv"), na = "NA") %>% 
   mutate_if(is.character, as.factor) %>%  kable("html") %>%
  kable_styling("striped", position = "left")
```

## The Cophylogeny Dataset

### Table of the dataset

Below is the dataset used for our meta-analysis, followed by explanations of 24 variables extracted from the papers included (not all variables were used for our analyses; variables which were neither 'directly' nor 'indirectly' used in our analyses are indicated by *).

#### Table S1.2
The meta-analytic dataset of this study.

```{r}
# getting the data and formating some variables (turning chraracter vectors to factors)
full_data <- read_csv(here("data/2021-09-01-source-data-dat.csv"), na = "NA") %>% 
   mutate_if(is.character, as.factor)

# dataset to compare the same cophylogenies between the two methods

full_pair <- read_csv(here("data/2020-08-12-paried.csv"), na = "NA") %>% 
   mutate_if(is.character, as.factor)

# making a scrollable table
kable(full_data, "html") %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")
```

A. __authors__: The authors of the study and the date (citation form).

B. __year__: The year of publication of the study.

C. __host_tax_broad__:	Separation of the host group according to broader taxonomic units (e.g. vertebrate, invertebrate, microbe, plant).

D. __symbiont_tax_broad__:	Separation of the symbiont group according to broader taxonomic units (e.g. vertebrate, invertebrate, microbe, plant).

E. __symbiont_euk__*:	Whether the symbiont is eukaryotic (state ='yes'), or prokaryotic (state='no').

F. __symbiosis__:	The type of symbiont (e.g. parasite or mutualist). For this we followed the definition used by the authors of the study.

G. __endo_or_ecto__:	Whether the symbiont lives outside the host (i.e. is an ectosymbiont), or inside the host (i.e. is an endosymbiont).

H. __mode_of_transmission_broad__:	Whether the symbiont is transmitted vertically, horizontally, or both. For this, we followed the route of transmission specified by the authors of the study.

I. __mode_of_transmission_fine__*:	A finer-scale description of the mode of transmission of the symbiont (e.g. contact, vector, bodily fluid, vertical, trophic).

J. __Visiting_symbiont?__*	Whether the symbiont is resident on the host (resident), or makes visits to the host or hosts (visitor).

K. __host_tips_linked__:	The number of individual host taxa included in the cophylogenetic analysis.

L. __host_tips_linked_corrected__	The same measure as for column K, 'host_tips_linked', but reduced to only include one member of each host species. This is included because some authors include multiple individuals of the same host species. Without correction, this artificially increases the apparent number of host species included in the study.

M. __host_genera__:	A count of the number of host genera included in the cophylogenetic analysis.

N. __total_host_symbiont_links__	The total number of links between host and symbiont taxa recorded in a study. If all symbionts were strict specialists, this would equal the number of symbionts included in the study. However, because symbionts are often associated with more than one host, this value is often higher than the total number of symbionts included in the study.

O. __host_range_link_ratio__:	An estimation of symbiont host specificity, calculated by dividing the total number of links between hosts and symbionts (i.e. 'total_host_symbiont_links', column N), by the total number of symbionts included in the study (i.e. 'symbiont_tips_linked', column Q).

P. __host_range_taxonomic_breadth__:	An alternative estimation of symbiont host specificity, calculated by first summing the number of host taxonomic ranks linked to each symbiont (i.e. single host species = 1, multiple host species in the same genus = 2, multiple host genera = 3, multiple host families = 4, multiple host orders = 5), and dividing by the total number of symbionts included in the study (i.e. 'symbiont_tips_linked', column Q).

Q. __symbiont_tips_linked__	The number of individual symbiont taxa included in the cophylogenetic analysis.

R. __symbiont_genera__:	A count of the number of symbiont genera included in the cophylogenetic analysis.

S. __no_randomizations__:	The number of phylogenetic randomizations performed during the cophylogenetic analysis.

T. __p_value__:	The p-value reported for the cophylogenetic analysis, representing the likelihood that host and symbiont phylogenies display cospeciation.

U. __method__:	Whether TreeMap or ParaFit was used to obtain the reported p value.

### Table of sample sizes

Below we present our sample sizes for the two separate methods: TreeMap [@page1994parallel] and ParaFit [@legendre2002statistical] (and combined), in terms of effect sizes, papers, and different levels of categorical variables (factors).   

```{r}
# selecting out variables, which we used for our analysis
dat <- full_data %>% select(-symbiont_euk, -mode_of_transmission_fine, -`Visiting_symbiont?`)
pair <- full_pair %>% select(-symbiont_euk, -mode_of_transmission_fine, -`Visiting_symbiont?`)

# making a table of sample sizes for different variables
dat %>% group_by(method) %>% 
  summarise(
    `Effect sizes (analyses)` = n(),
    Studies = n(), 
    Papers = n_distinct(authors),
    `Vertebrate hosts` = sum(host_tax_broad == "Vert", na.rm = T), # na.rm is important when NA exists
    `Invertebrate hosts` = sum(host_tax_broad == "Invert", na.rm = T),
    `Plant hosts`  = sum(host_tax_broad == "Plant", na.rm = T),
    `Microbe hosts` = sum(host_tax_broad == "Microbe", na.rm = T),
    `Vertebrate symbionts` = sum(symbiont_tax_broad  == "Vert", na.rm = T),
    `Invertebrate symbionts` = sum(symbiont_tax_broad  == "Invert", na.rm = T),
    `Plant symbionts`  = sum(symbiont_tax_broad  == "Plant", na.rm = T),
    `Microbe symbionts` = sum(symbiont_tax_broad  == "Microbe", na.rm = T),
    `Parastic relationships` = sum(symbiosis == "Parasite", na.rm = T),
    `Mutualistic relatioships` = sum(symbiosis == "Mutualist", na.rm = T),
    `Ecto-symbionts` = sum(endo_or_ecto  == "Ecto", na.rm = T),
    `Endo-symbionts` = sum(endo_or_ecto == "Endo", na.rm = T),
    `Ecto/endo-symbionts` = sum(endo_or_ecto == "Endo/Ecto", na.rm = T),
    `Horizontal transmission` = sum(mode_of_transmission_broad  == "horizontal", na.rm = T),
    `Vertical transmission` = sum(mode_of_transmission_broad == "vertical", na.rm = T),
    `Horizontal/vertical-transmission` = sum(mode_of_transmission_broad == "both", na.rm = T)
  ) -> n_table1

# transposing the table and creating that table and adding a correct number of the papers for `Combined`
n_authors <- n_distinct(dat$authors) # the total number of papers
dat$studies <- paste0(dat$authors, dat$host_tax_fine, dat$symbiont_tax_fine, dat$total_host_symbioint_links) # the number of analyses (studies)
n_studies <- n_distinct(dat$studies)
n_table2 <-t(n_table1[,-1])
colnames(n_table2) <- n_table1$method
n_table2 %>% as_tibble(rownames = "Number") %>% 
  mutate(Combined = Parafit + TreeMap, Combined = replace(Combined, c(2,3), c(n_studies, n_authors))) %>%  
  rename("Number of" = "Number", "ParaFit (n)" = "Parafit", "TreeMap (n)" = "TreeMap",  "Combined (n)" = "Combined") %>% 
  kable() %>% kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "250px")
  #pander(split.cell = 40, split.table = Inf) # not as nice as kable
```
Note that the numbers of studies and papers does not add up (TreeMap + ParaFit $\neq$ Combined), because `r sum(n_table2[2,]) - length(unique(dat$studies))` analyses and `r sum(n_table2[3,]) - length(unique(dat$authors))`  papers used both the TreeMap and ParaFit methods (the term "papers" here is our variable `authors`)

### Missing data patterns

Below, we present the number of instances of missing data (cells) for all variables used in our meta-analysis.

```{r}
# summaring missingness in our dataset
# funs(sum(is.na(.))) needs to be in funs as is.na has "." = each column
dat %>% summarise_all(~sum(is.na(.))) %>% # map(~sum(is.na(.)) # this is an alterantive way 
  t() %>% as_tibble(rownames = "Variable") %>% 
  rename("Number of missing data (n)" = "V1") %>% 
  #pander(split.cell = 40, split.table = Inf)
  kable() %>% kable_styling("striped", position = "left") %>%
  scroll_box(width = "60%", height = "250px")

# an alternative method using the mi package
#missing_data_tbl <- missing_data.frame(as.data.frame(data))
#show(missing_data_tbl) 
```

## Appendix S2: Meta-analysis

### Calculating effect sizes

We created our effect size (correlation coefficient *r* and its Fisher's z transformation *Zr*) from p values and associated sample sizes [@rosenthal2003requivalent]. We used half of the"effective sample size" for each effect size (an indicator of congruence): 

$$
N_{effective} = \frac{4n_{h}n_{s}} {n_{h} + n_{s}},
$$
where $n_h$ and $n_s$ are sample size for hosts and symbionts (in our case: `host_tips_linked_corrected` and `symbiont_tips_linked`). When $n = n_h = n_s$, $N_{effective}$ simplifies to $2n$. We used $N_{effective}/2$, which we called the number of "effective pairs" ($N_{ep}$) as our sample size. 

Also, we created a column with a unique ID for each observation (i.e. an observation level random effect), termed `observation`, which is required for the `rma.mv` function in `metafor` [@viechtbauer2010conducting].

```{r}
dat %<>% 
  # getting sample size & observation level random effect
  mutate(., sample_size = 2*(host_tips_linked_corrected*symbiont_tips_linked)/(host_tips_linked_corrected + symbiont_tips_linked),
         observation = factor(1:nrow(.))) #, signficance = if_else(p_value <= 0.05, "y", "n") ) 

# making p = 1 to p = (no_randomization - 1)/no_randomization as p = 1 produces t value = Inf
dat$p_value <- ifelse(dat$p_value != 1, dat$p_value, (dat$no_randomizations - 1)/dat$no_randomizations) 

# calculating effect size 
dat %<>% p_to_Zr(p_value, sample_size) 

# getting sample size for spp
# sum(dat$sample_size[match(unique(dat$studies), dat$studies)])

# getting effect sizes for pair data
pair %<>% 
  # getting sample size & observation level random effect
  mutate(., sample_size = 2*(host_tips_linked_corrected*symbiont_tips_linked)/(host_tips_linked_corrected + symbiont_tips_linked),
         observation = factor(1:nrow(.)))  
 
# making p = 1 to p = (no_randomization - 1)/no_randomization as p = 1 produces t value = Inf
pair$p_value_tree <- ifelse(pair$p_value_tree == 1, 0.999, pair$p_value_tree)  
# calculating effect size   
pair %<>% p_to_Zr(p_value_para, sample_size) %>% 
  rename(rval_para = rval, Zr_para = Zr, VZr_para = VZr) %>% 
  p_to_Zr(p_value_tree, sample_size) %>% 
  rename(rval_tree = rval, Zr_tree = Zr, VZr_tree = VZr) 

```

### Correlating two methods on the same cophylogenetic data

In 16 studies, authors used both `ParaFit` and `TreeMap` on the same cophylogeny dataset, but in some of these studies, they used different numbers of randomization between the two methods. Among these 16, 11 studies used `ParaFit` and `TreeMap` with the same or similar number of randomization (e.g., 999 and 1,000). We here correlated effect sizes (Zr) between these two methods. In the following analyses, we assume the p-value based effect size, Zr~equivalent (or just Zr) is equivalent for both methods. In such a case, we would require a tight correlation between the method.

```{r}

# plotting  correlations but not displayed
# A)
cor_1 <- round(with(pair, cor(Zr_para, Zr_tree)), 3)
cor_t1 <- with(pair, cor.test(Zr_para, Zr_tree))
               
all_plot <- ggplot(pair, aes(Zr_para, Zr_tree)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
    labs(x = "Zr (ParaFit)", y = "Zr (TreeMap)") + 
    annotate("text", x = 1, y = -1, label = paste("r = ", cor_1))

# B)
cor_2 <- round(with(pair[pair$match == "y", ], cor(Zr_para, Zr_tree)), 3)
cor_t2 <- with(pair[pair$match == "y", ], cor.test(Zr_para, Zr_tree))

part_plot <- ggplot(pair[pair$match == "y", ], aes(Zr_para, Zr_tree)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
   labs(x = "Zr (ParaFit)", y = "Zr (TreeMap)") + 
    annotate("text", x = 1, y = -1, label = paste("r = ", cor_2))

comb_plot <- all_plot + part_plot + plot_annotation(tag_levels = "A", tag_suffix = ")")
#comb_plot
```

There are strong and significant correlations in effect sizes (Zr) between `ParaFit` and `TreeMap` (for all the 16 studies, r = `r cor_1`, t = `r round(cor_t1$statistic , 3)`, df = `r as.numeric(cor_t1$parameter)`, p = `r round(cor_t1$p.value,4)`, and for the 11 perfectly matching studies, r = `r cor_2`, t = `r round(cor_t2$statistic , 3)`, df = `r as.numeric(cor_t2$parameter)`, p = `r round(cor_t2$p.value,4)`). Therefore, we have made an assumption that effect sizes based on p values from these two methods can be equated in our analyses below. 

### Meta-analytic model: testing Fahrenholz's rule

First, we checked what random effects should be put into the main model. To do this we fitted two random effects, `authors` (i.e. study IDs) and `observation`; the former term was added to account for non-independence of effect sizes originating from the same papers (i.e., `authors`). 

```{r, cache=TRUE}
# 2 random effects & model AIC 
# note that probably only base stuff works outside of main chunck so need to create AIC here
ma_test1 <- rma.mv(yi = Zr, 
                   V = VZr, 
                   random = list(~ 1 | authors, ~1|observation), 
                   data = dat)
aic1 <- AIC(ma_test1)

# 1 random effect & model AIC 
ma_test2 <- rma.mv(yi = Zr, 
                   V = VZr, 
                   random = ~ 1 | authors, 
                   data = dat)
aic2 <- AIC(ma_test2)
```

The model (`ma_test1`), which included both random factors, had a larger AIC value (`r round(aic1,2)`) than the model with only one random effect (`r round(aic2, 2)`) . This is because `observation` hardly accounted for any variance (< 0.0001) compared to `authors` (`r round(ma_test1$sigma2[1], 4)`). Therefore, we only included `authors` as our random factor in subsequent analyses.

We ran intercept models (meta-analyses) with 3 different datasets (`ParaFit`, `TreeMap` and both combined; see the explanation of `method` above). Also, we note that we used adjustments for test statistics and confidence intervals (`test = "t"`), which is similar to (but not the same as) those proposed by Knapp and Hartung [@knapp2003improved]; probably this approach is more conservative.

#### Running Multilevel Meta-analytic models with 3 datasets
```{r, cache=TRUE}
# think about making this into a tibble
# meta-analysis with Parafit
ma_parafit <- rma.mv(yi = Zr, 
                 V = VZr, 
                 random = ~ 1 | authors, 
                 test = "t",
                 subset = which(method == "TreeMap"),
                 data = dat)

# meta-analysis with TreeMap
ma_treemap <- rma.mv(yi = Zr, 
                 V = VZr, 
                 random = ~ 1 | authors, 
                 test = "t",
                 subset = which(method == "Parafit"),
                 data = dat)

# meta-analysis with all the data combined
ma_all <- rma.mv(yi = Zr, 
                 V = VZr, 
                 test = "t",
                 random = ~ 1 | authors, 
                 data = dat)
```

#### Table S2.1
Overall effects (meta-analytic means) and 95% confidence intervals (CIs) both in Zr and r,  and variance components (V) and heterogeneity, *I*^2^ (I2) [@higgins2003measuring] from the `metafor` model using the 3 datasets (`ParaFit`, `TreeMap` and both combined, or `All`). Note that in these models, *I*^2^~[total]~ = *I*^2^~[authors]~ (see [@nakagawa2012methodological;@senior2016heterogeneity]), as we only have one random factor. 
```{r}
# getting I2 for the models
# could use map()
i2_treemap <- I2(ma_treemap)
i2_parafit <- I2(ma_parafit)
i2_all <- I2(ma_all)
# creating a table
tibble(
  Dataset = c("Parafit (Zr)", "TreeMap (Zr)", "All (Zr)", "Parafit (r)", "TreeMap (r)", "All (r)"),
  `Overall mean` = c(ma_parafit$b, ma_treemap$b, ma_all$b, tanh(ma_parafit$b), tanh(ma_treemap$b), tanh(ma_all$b)),
  `Lower CI [0.025]` = c(ma_parafit$ci.lb, ma_treemap$ci.lb, ma_all$ci.lb, tanh(ma_parafit$ci.lb), tanh(ma_treemap$ci.lb), tanh(ma_all$ci.lb)),
  `Upper C  [0.975]` = c(ma_parafit$ci.ub, ma_treemap$ci.ub, ma_all$ci.ub,  tanh(ma_parafit$ci.ub), tanh(ma_treemap$ci.ub), tanh(ma_all$ci.ub)),
  `V[authors]` = c(ma_parafit$sigma2, ma_treemap$sigma2, ma_all$sigma2, rep(NA, 3)),
  `I2[total]` = c(i2_parafit[1], i2_treemap[1], i2_all[1], rep(NA, 3))) %>% 
  kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left")
```

These models all gave consistent results including heterogeneity. Given these results, we proceeded with only analyzing the whole dataset (`All`) from here on.    

#### Figure 3a

```{r,  fig.width=7, fig.height=2}
# https://stackoverflow.com/questions/41919023/ggplot-adding-image-on-top-right-in-two-plots-with-different-scales
# how to add png files to the figure (above)
# reading image
image_mutualism <- readPNG(here("images/mutualism_transparentbg.png"))
image_parasitism <- readPNG(here("images/parasitism_transparentbg.png"))

# creating a table of results
pred_ma <- get_pred(ma_all) 
effect_ma <- get_est(ma_all) %>% left_join(pred_ma) 

# creating An orchard plot
fig_ma <- ggplot(data = effect_ma, aes(x = tanh(estimate), y = "Overall mean")) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat, aes(x= tanh(Zr), y = "Overall mean", size = (1/VZr) + 3), groupOnX = FALSE, alpha=0.2) + 
  # precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +

  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(size=3, shape=21, fill = "black") +
  annotate('text', x = 0.93, y = 1.15, label=paste("italic(k)==", length(dat$Zr)), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pair)")) ) +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2)
#ggsave(plot = fig_ma, filename = "fig_2a.pdf", height = 2, width = 8)
# ggploty 0 does not work (Error in unique.default(x) : unimplemented type 'expression' in 'HashTableSetup')
fig_ma

# for Fig 3

a <- ggplot(data = effect_ma, aes(x = tanh(estimate), y = "Overall mean")) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat, aes(x= tanh(Zr), y = "Overall mean", size = (1/VZr) + 3), groupOnX = FALSE, alpha=0.2) + 
  # precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +

  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(size=3, shape=21, fill = "black") +
  annotate('text', x = 0.93, y = 1.15, label=paste("italic(k)==", length(dat$Zr)), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = "", y = "", size = expression(paste(italic(n), " (# of species pairs)")) ,tag = "a") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2)

```

**Figure 3a:** An orchard plot  showing the meta-analytic mean (mean effect size) with its 95% confidence interval (thick line) and 95% prediction interval (thin line), with observed effect sizes based on various sample sizes.  

## Appendix S3: Meta-regression

We ran a univariate meta-regression model for each of the following moderators: 1) `symbiosis`, 2) `host_tax_broad`, 3) `symbiont_tax_broad`, 4) `host_range_link_ratio`, 5) `host_range_taxonomic_breadth`, 6) `mode_of_transmission_broad`, and 7) `endo_or_ecto`. The results from these models are presented in the main text. 

In addition to these, we ran three more univariate models: 1) `host_tax_symbiosis` (equivalent to the interaction term between `symbiosis` and `host_tax_symbiosis`; `symbiosis*host_tax_symbiosis`), 2) `symbiont_tax_symbiosis` (`symbiosis*symbiont_tax_broad`),  3) `host_symbiont_tax` (`host_tax_symbiosis*symbiont_tax_broad`) and 4) `symbiosis_transmission` (`symbiosis*mode_of_transmission_broad`). These moderators are created below:

```{r}
dat %<>% 
    # host_tax_broad*symbiosis (host_tax_symbiosis) 
  mutate(host_tax_symbiosis = str_c(host_tax_broad, symbiosis), 
         host_tax_symbiosis = ifelse(host_tax_symbiosis == "InvertNA", NA, host_tax_symbiosis),
         host_tax_symbiosis = factor(host_tax_symbiosis),
         # symbiont_tax_broad*symbiosis (symbiont_tax_symbiosis)     
         symbiont_tax_symbiosis = factor(str_c(symbiont_tax_broad, symbiosis)),
         # host_tax_broad*symbiont_tax_broad (host_symbiont_tax)     
         host_symbiont_tax  = factor(str_c(host_tax_broad, symbiont_tax_broad)),
         # symbiosis*mode_of_transmission_broad (symbiosis_transmission)
         symbiosis_transmission  = factor(str_c(symbiosis, mode_of_transmission_broad)),
         # whether p values were the smallest value given the number of randamization - limit_researched (Yes = 1, No = 0)
         limit_reached = if_else(abs((1/p_value) - no_randomizations) <= 1, 1, 0))

```

### Univariate (uni-predictor) analyses

We first conducted a series of meta-regression models with each of the moderators introduced above. 

#### The type of symbiosis: parasitism vs. mutualism

```{r}
# meta-regression: mutiple intercepts
mr_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
# meta-regression: contrast
mr_symbiosis2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

#### Table S3.1
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ [@nakagawa2013general] (R2) from the meta-regression with `symbiosis`. Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.

```{r}
# getting marginal R2
r2_symbiosis1 <- R2(mr_symbiosis1)

# getting estimates``
res_symbiosis1 <- get_est(mr_symbiosis1, mod = "symbiosis")
res_symbiosis2 <- get_est(mr_symbiosis2, mod = "symbiosis")

# creating a table
tibble(
  `Fixed effect` = c(rep(as.character(res_symbiosis1$name),2), cont_gen(res_symbiosis1$name)),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 2), "Zr (beta)"),
  Estimate = c(res_symbiosis1$estimate, tanh(res_symbiosis1$estimate), res_symbiosis2$estimate[2]),
  `Lower CI [0.025]` = c(res_symbiosis1$lowerCL, tanh(res_symbiosis1$lowerCL), res_symbiosis2$lowerCL[2]),
  `Upper CI  [0.975]` = c(res_symbiosis1$upperCL, tanh(res_symbiosis1$upperCL), res_symbiosis2$upperCL[2]),
  `V[authors]` = c(mr_symbiosis1$sigma2,  rep(NA, 4)),
  `R2` = c(r2_symbiosis1[1], rep(NA, 4))) -> t_symbiosis
t_symbiosis %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```
#### Figure 3b 


```{r, fig.width=7, fig.height=2.5}
# adding sample size (k) for each category
k_symbiosis <- dat %>% group_by(symbiosis) %>% count()
# getting estimates and predicitons
pred_symbiosis <- get_pred(mr_symbiosis1, mod = "symbiosis") 
res_symbiosis1 <- left_join(res_symbiosis1, k_symbiosis, by =  c("name" = "symbiosis"))  %>% left_join(pred_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiosis <- ggplot(data = res_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis)), 
                   aes(x= tanh(Zr), y = symbiosis, size = ((1/VZr) + 3), colour = symbiosis), groupOnX = FALSE, alpha=0.2) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  scale_fill_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  annotate('text', x = 0.93, y = c(1.15, 2.15), label= paste("italic(k)==", res_symbiosis1$n), parse = TRUE, hjust = "left", size = 3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_mutualism), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2)

fig_symbiosis

# fig 3

b <- ggplot(data = res_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis)), 
                   aes(x= tanh(Zr), y = symbiosis, size = ((1/VZr) + 3), colour = symbiosis), groupOnX = FALSE, alpha=0.2) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  scale_fill_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  annotate('text', x = 0.93, y = c(1.15, 2.15), label= paste("italic(k)==", res_symbiosis1$n), parse = TRUE, hjust = "left", size = 3.5) +
  labs(x = "", y = "", tag = "b") +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_mutualism), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2)
```

**Figure 3b:** An orchard plot showing the group-wise means (the categorical variable `symbiosis`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.  


#### The effect of host taxa

```{r}
# reordering
dat$host_tax_broad <- factor(dat$host_tax_broad, levels = c("Microbe", "Plant", "Invert", "Vert"))

# meta-regression: mutiple intercepts
mr_host_tax_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_host_tax_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_host_tax_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_broad, ref = "Plant"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 3
mr_host_tax_broad4 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_broad, ref = "Invert"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

#### Table S3.2
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_host_tax_broad1 <- R2(mr_host_tax_broad1)

# getting estimates
res_host_tax_broad1 <- get_est(mr_host_tax_broad1, mod = "host_tax_broad")
res_host_tax_broad2 <- get_est(mr_host_tax_broad2, mod = "host_tax_broad")
# the name bit does not work if relevel....
res_host_tax_broad3 <- get_est(mr_host_tax_broad3, mod = "host_tax_broad")
res_host_tax_broad4 <- get_est(mr_host_tax_broad4, mod = "host_tax_broad")

# creating a table
tibble(
  `Fixed effect` = c(rep(as.character(res_host_tax_broad1$name),2), cont_gen(res_host_tax_broad1$name)),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 4), rep("Zr (beta)", 6)),
  Estimate = c(res_host_tax_broad1$estimate, tanh(res_host_tax_broad1$estimate), res_host_tax_broad2$estimate[-1],  res_host_tax_broad3$estimate[-(1:2)], res_host_tax_broad4$estimate[-(1:3)]),
  `Lower CI [0.025]` = c(res_host_tax_broad1$lowerCL, tanh(res_host_tax_broad1$lowerCL), res_host_tax_broad2$lowerCL[-1], res_host_tax_broad3$lowerCL[-(1:2)], res_host_tax_broad4$lowerCL[-(1:3)]),
  `Upper CI  [0.975]` = c(res_host_tax_broad1$upperCL, tanh(res_host_tax_broad1$upperCL), res_host_tax_broad2$upperCL[-1], res_host_tax_broad3$upperCL[-(1:2)], res_host_tax_broad4$upperCL[-(1:3)]),
  `V[authors]` = c(mr_host_tax_broad1$sigma2,  rep(NA, 13)),
  `R2` = c(r2_host_tax_broad1[1], rep(NA, 13))) -> t_host_tax

t_host_tax %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure 3c
```{r, fig.width=7, fig.height= 4}
# getting images
image_invertebrate_host <- readPNG(here("images/invertebrate_host_transparentbg.png"))
image_microbe_host <- readPNG(here("images/microbe_host_transparentbg.png"))
image_vertebrate_host <- readPNG(here("images/vertebrate_host_transparentbg.png"))
image_plant_host <- readPNG(here("images/plant_host_transparentbg.png"))

# adding sample size (k) for each category
k_host_tax_broad <- dat %>% group_by(host_tax_broad) %>% count()
# getting estimates and predicitons
pred_host_tax_broad <- get_pred(mr_host_tax_broad1, mod = "host_tax_broad") 
res_host_tax_broad1 <- left_join(res_host_tax_broad1, k_host_tax_broad, by =  c("name" = "host_tax_broad"))  %>% left_join(pred_host_tax_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_tax_broad <- ggplot(data = res_host_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_tax_broad)), 
                   aes(x= tanh(Zr), y = host_tax_broad, size = ((1/VZr) + 3), colour = host_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = 0.93, y = 1:4 + 0.15, label= paste("italic(k)==", res_host_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_plant_host), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1, xmax = -0.8, ymin = 3.6, ymax = 4.2)

fig_host_tax_broad

# fig 3c
c <- ggplot(data = res_host_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_tax_broad)), 
                   aes(x= tanh(Zr), y = host_tax_broad, size = ((1/VZr) + 3), colour = host_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = 0.93, y = 1:4 + 0.15, label= paste("italic(k)==", res_host_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = "", y = "", size = expression(paste(italic(n), " (# of species pairs)")) , tag = "c") +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_plant_host), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1, xmax = -0.8, ymin = 3.6, ymax = 4.2)
```

**Figure 3c:** An orchard plot showing the group-wise means (the categorical variable `host_tax_broad`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.  

#### The effect of symbiont taxa

```{r}
# reordering
dat$symbiont_tax_broad <- factor(dat$symbiont_tax_broad, levels = c("Microbe", "Plant", "Invert", "Vert"))

#sizes <- factor(sizes, levels = c("small", "medium", "large"))
#sizes
#> [1] small  large  large  small  medium
#> Levels: small medium large
# meta-regression: mutiple intercepts
mr_symbiont_tax_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_symbiont_tax_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_symbiont_tax_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_broad, ref = "Plant"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 3
mr_symbiont_tax_broad4 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_broad, ref = "Invert"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

#### Table S3.3
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_symbiont_tax_broad1 <- R2(mr_symbiont_tax_broad1)

# getting estimates
res_symbiont_tax_broad1 <- get_est(mr_symbiont_tax_broad1, mod = "symbiont_tax_broad")
res_symbiont_tax_broad2 <- get_est(mr_symbiont_tax_broad2, mod = "symbiont_tax_broad")
res_symbiont_tax_broad3 <- get_est(mr_symbiont_tax_broad3, mod = "symbiont_tax_broad")
res_symbiont_tax_broad4 <- get_est(mr_symbiont_tax_broad4, mod = "symbiont_tax_broad")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiont_tax_broad1$name),as.character(res_symbiont_tax_broad1$name), cont_gen(res_symbiont_tax_broad1$name)),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 4), rep("Zr (beta)", 6)),
  Estimate = c(res_symbiont_tax_broad1$estimate, tanh(res_symbiont_tax_broad1$estimate), res_symbiont_tax_broad2$estimate[-1],  res_symbiont_tax_broad3$estimate[-(1:2)], res_symbiont_tax_broad4$estimate[-(1:3)]),
  `Lower CI [0.025]` = c(res_symbiont_tax_broad1$lowerCL, tanh(res_symbiont_tax_broad1$lowerCL), res_symbiont_tax_broad2$lowerCL[-1], res_symbiont_tax_broad3$lowerCL[-(1:2)], res_symbiont_tax_broad4$lowerCL[-(1:3)]),
  `Upper CI  [0.975]` = c(res_symbiont_tax_broad1$upperCL, tanh(res_symbiont_tax_broad1$upperCL), res_symbiont_tax_broad2$upperCL[-1], res_symbiont_tax_broad3$upperCL[-(1:2)], res_symbiont_tax_broad4$upperCL[-(1:3)]),
  `V[authors]` = c(mr_symbiont_tax_broad1$sigma2,  rep(NA, 13)),
  `R2` = c(r2_symbiont_tax_broad1[1], rep(NA, 13))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure 3d
```{r, fig.width=7, fig.height= 4}
# getting images
image_invertebrate_parasite <- readPNG(here("images/invertebrate_parasite_transparentbg.png"))
image_microbe_parasite <- readPNG(here("images/microbe_parasite_transparentbg.png"))
image_vertebrate_parasite <- readPNG(here("images/vertebrate_parasite_transparentbg.png"))
image_plant_parasite <- readPNG(here("images/plant_parasite_transparentbg.png"))

# adding sample size (k) for each category
k_symbiont_tax_broad <- dat %>% group_by(symbiont_tax_broad) %>% count()
# getting estimates and predicitons
pred_symbiont_tax_broad <- get_pred(mr_symbiont_tax_broad1, mod = "symbiont_tax_broad") 
res_symbiont_tax_broad1 <- left_join(res_symbiont_tax_broad1, k_symbiont_tax_broad, by =  c("name" = "symbiont_tax_broad"))  %>% left_join(pred_symbiont_tax_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiont_tax_broad <- ggplot(data = res_symbiont_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiont_tax_broad)), 
                   aes(x= tanh(Zr), y = symbiont_tax_broad, size = ((1/VZr) + 3), colour = symbiont_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00" )) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = 0.93, y = 1:4 + 0.15, label= paste("italic(k)==", res_symbiont_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertebrate_parasite), xmin = -1, xmax = -0.8, ymin = 3.6, ymax = 4.2)

fig_symbiont_tax_broad

# fig 3d
d <- ggplot(data = res_symbiont_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiont_tax_broad)), 
                   aes(x= tanh(Zr), y = symbiont_tax_broad, size = ((1/VZr) + 3), colour = symbiont_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00" )) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = 0.93, y = 1:4 + 0.15, label= paste("italic(k)==", res_symbiont_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")), tag = "d") +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -1, xmax = -0.8, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertebrate_parasite), xmin = -1, xmax = -0.8, ymin = 3.6, ymax = 4.2)

```

**Figure 3d:** An orchard plot showing the group-wise means (the categorical variable `symbiont_tax_broad`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.  


#### Testing specialization 1: host range

```{r}
# meta-regression
mr_host_range_link_ratio <- rma.mv(yi = Zr, V = VZr, mods = ~ log(host_range_link_ratio), random = ~ 1 | authors, data = dat)

```

#### Table S3.4
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `log(host_range_link_ratio)`.  Note that `mu` shows the overall while `beta` represents a slope in the Unit column.
```{r}
# getting marginal R2
r2_host_range_link_ratio <- R2(mr_host_range_link_ratio)

# getting estimates: name does not work for slopes
res_host_range_link_ratio <- get_est(mr_host_range_link_ratio, mod = "log(host_range_link_ratio)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "Intercept", "log(host_range_link_ratio)"),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),1), rep("Zr (beta)", 1)),
  Estimate = c(res_host_range_link_ratio$estimate[1], tanh(res_host_range_link_ratio$estimate[1]), res_host_range_link_ratio$estimate[2]),
  `Lower CI [0.025]` = c(res_host_range_link_ratio$lowerCL[1], tanh(res_host_range_link_ratio$lowerCL[1]), res_host_range_link_ratio$lowerCL[2]),
  `Upper CI  [0.975]` = c(res_host_range_link_ratio$upperCL[1], tanh(res_host_range_link_ratio$upperCL[1]),res_host_range_link_ratio$upperCL[2]),
  `V[authors]` = c(mr_host_range_link_ratio$sigma2, NA, NA),
  `R2` = c(r2_host_range_link_ratio[1], NA, NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
# newmods <- seq(-0.3, 2.2, by = 0.1)
# pred_host_range_link_ratio <-predict.rma(mr_host_range_link_ratio, newmods = newmods) 
# ribbon_dat <- tibble(newmods = newmods, ymin = pred_host_range_link_ratio$ci.lb, ymax = pred_host_range_link_ratio$ci.ub)
pred_host_range_link_ratio <-predict.rma(mr_host_range_link_ratio) 

# plotting

fig_host_range_link_ratio <-  dat %>% 
  filter(!is.na(host_range_link_ratio))  %>% # getting ride of NA values
  mutate(ymin = pred_host_range_link_ratio$ci.lb, 
         ymax = pred_host_range_link_ratio$ci.ub,
         ymin2 = pred_host_range_link_ratio$cr.lb,
         ymax2 = pred_host_range_link_ratio$cr.ub,
         pred = pred_host_range_link_ratio$pred) %>% 
  ggplot(aes(x = log(host_range_link_ratio), y = Zr, size = (1/VZr) + 3, )) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(-0.05, 2) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "ln(host range link ratio)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(1, 1), legend.justification = c(1, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_range_link_ratio
```

#### Figure S3.1 
A bubble plot showing a predicted regression line for the continuous variable `log(host_range_link_ratio)`, indicating 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines) with observed effect sizes based on various sample sizes. 


#### Testing specialization 2: taxonomic breadth

```{r}
# meta-regression
mr_host_range_taxonomic_breadth <- rma.mv(yi = Zr, V = VZr, mods = ~ log(host_range_taxonomic_breadth), random = ~ 1 | authors, data = dat)

```

#### Table S3.5
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `log(host_range_taxonomic_breadth)`.  Note that `mu` shows the overall while `beta` represents a slope in the Unit column.
```{r}
# getting marginal R2
r2_host_range_taxonomic_breadth <- R2(mr_host_range_taxonomic_breadth)

# getting estimates: name does not work for slopes
res_host_range_taxonomic_breadth <- get_est(mr_host_range_taxonomic_breadth, mod = "log(host_range_taxonomic_breadth)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept","Intercept", "log(host_range_taxonomic_breadth)"),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),1), rep("Zr (beta)", 1)),
  Estimate = c(res_host_range_taxonomic_breadth$estimate[1],tanh(res_host_range_taxonomic_breadth$estimate[1]) ,res_host_range_taxonomic_breadth$estimate[2]),
  `Lower CI [0.025]` = c(res_host_range_taxonomic_breadth$lowerCL[1], tanh(res_host_range_taxonomic_breadth$lowerCL[1]),res_host_range_taxonomic_breadth$lowerCL[2]),
  `Upper CI  [0.975]` = c(res_host_range_taxonomic_breadth$upperCL[1], tanh(res_host_range_taxonomic_breadth$upperCL[1]) ,res_host_range_taxonomic_breadth$upperCL[2]),
  `V[authors]` = c(mr_host_range_taxonomic_breadth$sigma2, NA, NA),
  `R2` = c(r2_host_range_taxonomic_breadth[1], NA, NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_host_range_taxonomic_breadth <-predict.rma(mr_host_range_taxonomic_breadth) 

# plotting

fig_host_range_taxonomic_breadth <-  dat %>% 
  filter(!is.na(host_range_taxonomic_breadth))  %>% # getting ride of NA values
  mutate(ymin = pred_host_range_taxonomic_breadth$ci.lb, 
         ymax = pred_host_range_taxonomic_breadth$ci.ub,
         ymin2 = pred_host_range_taxonomic_breadth$cr.lb,
         ymax2 = pred_host_range_taxonomic_breadth$cr.ub,
         pred = pred_host_range_taxonomic_breadth$pred) %>% 
  ggplot(aes(x = log(host_range_taxonomic_breadth), y = Zr, size = (1/VZr) + 3, )) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0, 1.5) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "ln(host range taxonomic breadth)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(1, 1), legend.justification = c(1, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_range_taxonomic_breadth
```

#### Figure S3.2
A bubble plot showing a predicted regression line for the continuous variable `log(log(host_range_taxonomic_breadth)`, indicating 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines) with observed effect sizes based on various sample sizes. 


#### Symbiont location on host: endosymbiosis vs. ectosymbiosis

```{r}
# reordering
dat$endo_or_ecto <- factor(dat$endo_or_ecto, levels = c("Endo/Ecto", "Endo", "Ecto"))

# meta-regression: mutiple intercepts
mr_endo_or_ecto1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ endo_or_ecto - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_endo_or_ecto2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ endo_or_ecto, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_endo_or_ecto3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(endo_or_ecto, ref = "Endo"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

```

#### Table S3.6
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `endo_or_ecto`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_endo_or_ecto1 <- R2(mr_endo_or_ecto1)

# getting estimates
res_endo_or_ecto1 <- get_est(mr_endo_or_ecto1, mod = "endo_or_ecto")
res_endo_or_ecto2 <- get_est(mr_endo_or_ecto2, mod = "endo_or_ecto")
res_endo_or_ecto3 <- get_est(mr_endo_or_ecto3, mod = "endo_or_ecto")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_endo_or_ecto1$name),as.character(res_endo_or_ecto1$name), cont_gen(res_endo_or_ecto1$name)),
   `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 3), rep("Zr (beta)", 3)),
  Estimate = c(res_endo_or_ecto1$estimate, tanh(res_endo_or_ecto1$estimate), res_endo_or_ecto2$estimate[-1],  res_endo_or_ecto3$estimate[-(1:2)]),
  `Lower CI [0.025]` = c(res_endo_or_ecto1$lowerCL, tanh(res_endo_or_ecto1$lowerCL), res_endo_or_ecto2$lowerCL[-1], res_endo_or_ecto3$lowerCL[-(1:2)]),
  `Upper CI  [0.975]` = c(res_endo_or_ecto1$upperCL, tanh(res_endo_or_ecto1$upperCL), res_endo_or_ecto2$upperCL[-1], res_endo_or_ecto3$upperCL[-(1:2)]),
  `V[authors]` = c(mr_endo_or_ecto1$sigma2,  rep(NA, 8)),
  `R2` = c(r2_endo_or_ecto1[1], rep(NA, 8))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

#### Figure 4a
```{r, fig.width=7, fig.height= 4}
# getting images
image_endoparasite <- readPNG(here("images/endoparasite_transparentbg.png"))
image_ectoparasite <- readPNG(here("images/ectoparasite_transparentbg.png"))

# adding sample size (k) for each category
k_endo_or_ecto <- dat %>% group_by(endo_or_ecto) %>% count()
# getting estimates and predicitons
pred_endo_or_ecto <- get_pred(mr_endo_or_ecto1, mod = "endo_or_ecto") 
res_endo_or_ecto1 <- left_join(res_endo_or_ecto1, k_endo_or_ecto, by =  c("name" = "endo_or_ecto"))  %>% left_join(pred_endo_or_ecto)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_endo_or_ecto <- ggplot(data = res_endo_or_ecto1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(endo_or_ecto)), 
                   aes(x= tanh(Zr), y = endo_or_ecto, size = ((1/VZr) + 3), colour = endo_or_ecto), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_fill_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_y_discrete(labels = c("Endo/Ecto" = "Both",  "Endo" = "Endosymbiosis",  "Ecto"= "Ectosymbiosis")) +
  annotate('text', x = 0.93, y = 1:3 + 0.15, label= paste("italic(k)==", res_endo_or_ecto1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction = "horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # adding images
  annotation_custom(rasterGrob(image_endoparasite), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_ectoparasite), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_ectoparasite), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_endoparasite), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2)

fig_endo_or_ecto

# fig 3e

e <- ggplot(data = res_endo_or_ecto1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(endo_or_ecto)), 
                   aes(x= tanh(Zr), y = endo_or_ecto, size = ((1/VZr) + 3), colour = endo_or_ecto), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_fill_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_y_discrete(labels = c("Endo/Ecto" = "Both",  "Endo" = "Endosymbiosis",  "Ecto"= "Ectosymbiosis")) +
  annotate('text', x = 0.93, y = 1:3 + 0.15, label= paste("italic(k)==", res_endo_or_ecto1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = "", y = "", size = expression(paste(italic(n), " (# of species pairs)")), tag = "e" ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # adding images
  annotation_custom(rasterGrob(image_endoparasite), xmin = -1, xmax = -0.8, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_ectoparasite), xmin = -1, xmax = -0.8, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_ectoparasite), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_endoparasite), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2)
```

**Figure 4a:**  An orchard plot showing the group-wise means (the categorical variable `endo_or_ecto`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes. 


#### The effect of the mode of transmission

```{r}
# meta-regression: mutiple intercepts
mr_mode_of_transmission_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ mode_of_transmission_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_mode_of_transmission_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ mode_of_transmission_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_mode_of_transmission_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(mode_of_transmission_broad, ref = "vertical"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

#### Table S3.7
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `mode_of_transmission_broad`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_mode_of_transmission_broad1 <- R2(mr_mode_of_transmission_broad1)

# getting estimates
res_mode_of_transmission_broad1 <- get_est(mr_mode_of_transmission_broad1, mod = "mode_of_transmission_broad")
res_mode_of_transmission_broad2 <- get_est(mr_mode_of_transmission_broad2, mod = "mode_of_transmission_broad")
res_mode_of_transmission_broad3 <- get_est(mr_mode_of_transmission_broad3, mod = "mode_of_transmission_broad")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_mode_of_transmission_broad1$name),as.character(res_mode_of_transmission_broad1$name),cont_gen(res_mode_of_transmission_broad1$name)),
   `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 3), rep("Zr (beta)", 3)),
  Estimate = c(res_mode_of_transmission_broad1$estimate, tanh(res_mode_of_transmission_broad1$estimate), res_mode_of_transmission_broad2$estimate[-1],  res_mode_of_transmission_broad3$estimate[-(1:2)]),
  `Lower CI [0.025]` = c(res_mode_of_transmission_broad1$lowerCL, tanh(res_mode_of_transmission_broad1$lowerCL), res_mode_of_transmission_broad2$lowerCL[-1], res_mode_of_transmission_broad3$lowerCL[-(1:2)]),
  `Upper CI  [0.975]` = c(res_mode_of_transmission_broad1$upperCL,tanh(res_mode_of_transmission_broad1$upperCL), res_mode_of_transmission_broad2$upperCL[-1], res_mode_of_transmission_broad3$upperCL[-(1:2)]),
  `V[authors]` = c(mr_mode_of_transmission_broad1$sigma2,  rep(NA, 8)),
  `R2` = c(r2_mode_of_transmission_broad1[1], rep(NA, 8))) -> t_transmission

t_transmission %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

#### Figure 4b
```{r, fig.width=7, fig.height= 3.5}
# getting images
image_horizontal <- readPNG(here("images/horizontal_transparentbg.png"))
image_vertical <- readPNG(here("images/vertical_transparentbg.png"))
image_both <- readPNG(here("images/horizontal_vertical_transparentbg.png"))
# adding sample size (k) for each category
k_mode_of_transmission_broad <- dat %>% group_by(mode_of_transmission_broad) %>% count()
# getting estimates and predicitons
pred_mode_of_transmission_broad <- get_pred(mr_mode_of_transmission_broad1, mod = "mode_of_transmission_broad") 
res_mode_of_transmission_broad1 <- left_join(res_mode_of_transmission_broad1, k_mode_of_transmission_broad, by =  c("name" = "mode_of_transmission_broad"))  %>% left_join(pred_mode_of_transmission_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_mode_of_transmission_broad <- ggplot(data = res_mode_of_transmission_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(mode_of_transmission_broad)), 
                   aes(x= tanh(Zr), y = mode_of_transmission_broad, size = ((1/VZr) + 3), colour = mode_of_transmission_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_fill_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_y_discrete(labels = c("both" = "Both",  "horizontal" = "Horizontal",  "vertical"= "Vertical")) +
  annotate('text', x = 0.93, y = (1:3 + 0.15), label= paste("italic(k)==", res_mode_of_transmission_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction = "horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # adding images
  annotation_custom(rasterGrob(image_horizontal), xmin = -1, xmax = -0.7, ymin = 1.4, ymax = 2.2) +
  annotation_custom(rasterGrob(image_vertical), xmin = -1, xmax = -0.7, ymin = 2.4, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_both), xmin = -1, xmax = -0.7, ymin = 0.4, ymax = 1.2) 

fig_mode_of_transmission_broad

# fig 3f

f <- ggplot(data = res_mode_of_transmission_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(mode_of_transmission_broad)), 
                   aes(x= tanh(Zr), y = mode_of_transmission_broad, size = ((1/VZr) + 3), colour = mode_of_transmission_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_fill_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_y_discrete(labels = c("both" = "Both",  "horizontal" = "Horizontal",  "vertical"= "Vertical")) +
  annotate('text', x = 0.93, y = (1:3 + 0.15), label= paste("italic(k)==", res_mode_of_transmission_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = "", y = "", size = expression(paste(italic(n), " (# of species pairs)")), tag = "f" ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # adding images
  annotation_custom(rasterGrob(image_horizontal), xmin = -1, xmax = -0.7, ymin = 1.4, ymax = 2.2) +
  annotation_custom(rasterGrob(image_vertical), xmin = -1, xmax = -0.7, ymin = 2.4, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_both), xmin = -1, xmax = -0.7, ymin = 0.4, ymax = 1.2) 


```

**Figure 4b:** An orchard plot showing the group-wise means (the categorical variable `mode_of_transmission_broad`), indicating 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.


#### The combined effect of symbiosis and mode of transmission

```{r}
# reordering
dat$symbiosis_transmission <- factor(dat$symbiosis_transmission,
                                 levels = c("Mutualistboth", "Mutualisthorizontal","Mutualistvertical", "Parasiteboth", "Parasitehorizontal"),
                                labels = c("MutualistBoth", "MutualistHorizontal","MutualistVertical", "ParasiteBoth", "ParasiteHorizontal"))

# meta-regression: mutiple intercepts
mr_symbiosis_transmission1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis_transmission - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$symbiosis_transmission)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiosis_transmission, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_symbiosis_transmission <- map(level_names[-length(level_names)], run_rma)

```

#### Table S3.8
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiosis_transmission`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_symbiosis_transmission1 <- R2(mr_symbiosis_transmission1)

# getting estimates
res_symbiosis_transmission1 <- get_est(mr_symbiosis_transmission1, mod = "symbiosis_transmission")
res_symbiosis_transmission <- map(mr_symbiosis_transmission, ~ get_est(.x, mod = "symbiosis_transmission"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:4)

# you need to flatten twice: first to make it a list and make it a vector
estimates <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiosis_transmission1$name),as.character(res_symbiosis_transmission1$name), cont_gen(res_symbiosis_transmission1$name)),
  `Unit` = c(rep(c("Zr (mu)", "r (mu)"),each = 5), rep("Zr (beta)", 10)),
  Estimate = c(res_symbiosis_transmission1$estimate, tanh(res_symbiosis_transmission1$estimate), estimates),
  `Lower CI [0.025]` = c(res_symbiosis_transmission1$lowerCL, tanh(res_symbiosis_transmission1$lowerCL), lowerCLs),
  `Upper CI  [0.975]` = c(res_symbiosis_transmission1$upperCL,tanh(res_symbiosis_transmission1$upperCL), upperCLs),
  `V[authors]` = c(mr_symbiosis_transmission1$sigma2,  rep(NA, (5 + 5 + choose(5,2))- 1)),
  `R2` = c(r2_symbiosis_transmission1[1], rep(NA, (5+5 + choose(5, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure 4c
```{r, fig.width=7, fig.height= 5}
# colour list
colour_ls <- c("#000000", "#E69F00", "#56B4E9", "#009E73",  "#F0E422",  "#0072B2",  "#D55E00", "#CC79A7", "#00008B", "#8B0A50", "#54FF9F", "#999999")

# adding sample size (k) for each category
k_symbiosis_transmission <- dat %>% group_by(symbiosis_transmission) %>% count()
# getting estimates and predicitons
pred_symbiosis_transmission <- get_pred(mr_symbiosis_transmission1, mod = "symbiosis_transmission") 
res_symbiosis_transmission1 <- left_join(res_symbiosis_transmission1, k_symbiosis_transmission, by =  c("name" = "symbiosis_transmission"))  %>% left_join(pred_symbiosis_transmission)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiosis_transmission <- ggplot(data = res_symbiosis_transmission1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis_transmission)), 
                   aes(x= tanh(Zr), y = symbiosis_transmission, size = ((1/VZr) + 3), colour = symbiosis_transmission), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =   c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_fill_manual(values = c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_y_discrete(labels = c("MutualistBoth" = "Mutualist-\nBoth", "MutualistHorizontal" = "Mutualist-\nHorizontal","MutualistVertical" = "Mutualist-\nVertical", "ParasiteBoth" = "Parasite-\nBoth", "ParasiteHorizontal" = "Parasite-\nHorizontal")) +
  annotate('text', x = 0.93, y = 1:5 + 0.15, label= paste("italic(k)==", res_symbiosis_transmission1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_both), xmin = -0.9, xmax = -0.6, ymin = 0.4, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_horizontal),xmin = -0.9, xmax = -0.6, ymin = 1.4, ymax = 2.2) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertical), xmin = -0.9, xmax = -0.6, ymin = 2.4, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -1.1, xmax = -0.9, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_both), xmin = -0.9, xmax = -0.6, ymin = 3.4, ymax = 4.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -1.1, xmax = -0.9, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_horizontal), xmin = -0.9, xmax = -0.6, ymin = 4.4, ymax = 5.2)

fig_symbiosis_transmission

## fig 3
g <- ggplot(data = res_symbiosis_transmission1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis_transmission)), 
                   aes(x= tanh(Zr), y = symbiosis_transmission, size = ((1/VZr) + 3), colour = symbiosis_transmission), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =   c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_fill_manual(values = c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_y_discrete(labels = c("MutualistBoth" = "Mutualist-\nBoth", "MutualistHorizontal" = "Mutualist-\nHorizontal","MutualistVertical" = "Mutualist-\nVertical", "ParasiteBoth" = "Parasite-\nBoth", "ParasiteHorizontal" = "Parasite-\nHorizontal")) +
  annotate('text', x = 0.93, y = 1:5 + 0.15, label= paste("italic(k)==", res_symbiosis_transmission1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ,tag = "g" ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position="none") +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_both), xmin = -0.9, xmax = -0.6, ymin = 0.4, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_horizontal),xmin = -0.9, xmax = -0.6, ymin = 1.4, ymax = 2.2) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -1.1, xmax = -0.9, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_vertical), xmin = -0.9, xmax = -0.6, ymin = 2.4, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -1.1, xmax = -0.9, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_both), xmin = -0.9, xmax = -0.6, ymin = 3.4, ymax = 4.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -1.1, xmax = -0.9, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_horizontal), xmin = -0.9, xmax = -0.6, ymin = 4.4, ymax = 5.2)

```

**Figure 4c:** An orchard plot showing the group-wise means (the categorical variable `symbiosis_transmission`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.

#### Putting together Figure 3

```{r, fig.width=8, fig.height= 14}
# building fig 3 using patchwork
fig3 <- (a / b / c / d + plot_layout(heights = c(1.6, 2, 3.7, 3.7)))


#fig3 <- (a / b / c / d + plot_layout(heights = c(1.6, 2, 3.7, 3.7))) | 
 # (e / f / g + plot_layout(heights = c(2.8, 2.8, 4.4))) #+ plot_annotation(tag_levels = 'a', tag_suffix = ')')
 
fig3

# ggsave(here("figs/fig3.png"), width = 8, height = 12)
# ggsave(here("figs/fig3.pdf"), width = 8, height = 12)
```
**Figure 3:** putting all 4 panels together: Figure 3a - Figure 3d (see the main text)

#### Putting together Figure 4

```{r, fig.width=8, fig.height= 14}
# building fig 3 using patchwork
fig4 <- (e / f / g + plot_layout(heights = c(2.8, 2.8, 4.4))) + plot_annotation(tag_levels = 'a')
 
fig4

# ggsave(here("figs/fig4.png"), width = 8, height = 12)
# ggsave(here("figs/fig4.pdf"), width = 8, height = 12)
```

**Figure 4:** putting all 3 panels together: Figure 4a - Figure 4c (see the main text)

### Additional analyses (uni-predictor)

These are extra analyses not discussed in the main text. 

#### The combined effect of host taxa and symbiosis (parasitism vs. mutualism)

```{r}
# reordering
dat$host_tax_symbiosis <- factor(dat$host_tax_symbiosis, 
                                 levels = c("MicrobeMutualist", "MicrobeParasite",  "PlantMutualist", "PlantParasite", "InvertMutualist",  "InvertParasite",  "VertMutualist", "VertParasite"))

# meta-regression: mutiple intercepts
mr_host_tax_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$host_tax_symbiosis)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_symbiosis, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_host_tax_symbiosis <- map(level_names[-length(level_names)], run_rma)

```

#### Table S3.9
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_symbiosis`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_host_tax_symbiosis1 <- R2(mr_host_tax_symbiosis1)

# getting estimates
res_host_tax_symbiosis1 <- get_est(mr_host_tax_symbiosis1, mod = "host_tax_symbiosis")
res_host_tax_symbiosis <- map(mr_host_tax_symbiosis, ~ get_est(.x, mod = "host_tax_symbiosis"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:7)

# you need to flatten twice: first to make it a list and make it a vector
estimates <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_host_tax_symbiosis1$name), cont_gen(res_host_tax_symbiosis1$name)),
  Estimate = c(res_host_tax_symbiosis1$estimate, estimates),
  `Lower CI [0.025]` = c(res_host_tax_symbiosis1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_host_tax_symbiosis1$upperCL,upperCLs),
  `V[authors]` = c(mr_host_tax_symbiosis1$sigma2,  rep(NA, (8 + choose(8,2))- 1)),
  `R2` = c(r2_host_tax_symbiosis1[1], rep(NA, (8 + choose(8, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure S3.3

```{r, fig.width=7, fig.height= 8}
# adding sample size (k) for each category
k_host_tax_symbiosis <- dat %>% group_by(host_tax_symbiosis) %>% count()
# getting estimates and predicitons
pred_host_tax_symbiosis <- get_pred(mr_host_tax_symbiosis1, mod = "host_tax_symbiosis") 
res_host_tax_symbiosis1 <- left_join(res_host_tax_symbiosis1, k_host_tax_symbiosis, by =  c("name" = "host_tax_symbiosis"))  %>% left_join(pred_host_tax_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_tax_symbiosis <- ggplot(data = res_host_tax_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_tax_symbiosis)), 
                   aes(x= tanh(Zr), y = host_tax_symbiosis, size = ((1/VZr) + 3), colour = host_tax_symbiosis), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =   c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertMutualist"= colour_ls[7],     "VertParasite"= colour_ls[8] )) +
  scale_fill_manual(values = c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertMutualist"= colour_ls[7],     "VertParasite"= colour_ls[8] )) +
  scale_y_discrete(labels = c("MicrobeMutualist"= "Microbe-\nMutualist", "MicrobeParasite"= "Microbe-\nParasite",  "PlantMutualist" = "Plant-\nMutualist", "PlantParasite"="Plant-\nParasite", "InvertMutualist" = "Invertebrate-\nMutualist",   "InvertParasite"= "Invertebrate-\nParasite", "VertMutualist"= "Vertebrate-\nMutualist",  "VertParasite"= "Vertebrate-\nParasite" )) +
  annotate('text', x = 0.93, y = 1:8 + 0.15, label= paste("italic(k)==", res_host_tax_symbiosis1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
  # putting pictures in
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1.1, xmax = -0.9, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_parasitism),xmin = -0.9, xmax = -0.7, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_plant_host), xmin = -1.1, xmax = -0.9, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_plant_host), xmin = -1.1, xmax = -0.9, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 6.6, ymax = 7.2) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 6.6, ymax = 7.2) +
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 7.6, ymax = 8.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 7.6, ymax = 8.2)

fig_host_tax_symbiosis
```

**Figure S3.3:** An orchard plot showing group-wise means (the categorical variable `host_tax_symbiosis`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.

Splitting host taxonomy by mode of symbiosis revealed that the observed higher phylogenetic congruence of host-symbiont cophylogenies involving a microbial host is driven primarily by greater congruence between microbial hosts and mutualist symbionts. Congruence is also relatively high for invertebrate hosts that harbour a mutualistic symbiont, while congruence appears to be lowest for plant hosts that harbour a parasitic symbiont. 

#### The combined effect of symbiont taxa and symbiosis (parasitism vs. mutualism)

```{r}
# reordering
dat$symbiont_tax_symbiosis <- factor(dat$symbiont_tax_symbiosis, 
                                     levels = c(  "MicrobeMutualist", "MicrobeParasite",  "PlantMutualist", "PlantParasite","InvertMutualist", "InvertParasite", "VertParasite"))

# meta-regression: multiple intercepts
mr_symbiont_tax_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$symbiont_tax_symbiosis)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_symbiosis, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_symbiont_tax_symbiosis <- map(level_names[-length(level_names)], run_rma)

```

#### Table S3.10
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_symbiosis`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_symbiont_tax_symbiosis1 <- R2(mr_symbiont_tax_symbiosis1)

# getting estimates
res_symbiont_tax_symbiosis1 <- get_est(mr_symbiont_tax_symbiosis1, mod = "symbiont_tax_symbiosis")
res_symbiont_tax_symbiosis <- map(mr_symbiont_tax_symbiosis, ~ get_est(.x, mod = "symbiont_tax_symbiosis"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:6)

# you need to flatten twice: first to make it a list and make it a vector
estimates <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiont_tax_symbiosis1$name), cont_gen(res_symbiont_tax_symbiosis1$name)),
  Estimate = c(res_symbiont_tax_symbiosis1$estimate, estimates),
  `Lower CI [0.025]` = c(res_symbiont_tax_symbiosis1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_symbiont_tax_symbiosis1$upperCL,upperCLs),
  `V[authors]` = c(mr_symbiont_tax_symbiosis1$sigma2,  rep(NA, (7 + choose(7,2))- 1)),
  `R2` = c(r2_symbiont_tax_symbiosis1[1], rep(NA, (7 + choose(7, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure S3.4
```{r, fig.width=7, fig.height= 7}
# adding sample size (k) for each category
k_symbiont_tax_symbiosis <- dat %>% group_by(symbiont_tax_symbiosis) %>% count()
# getting estimates and predicitons
pred_symbiont_tax_symbiosis <- get_pred(mr_symbiont_tax_symbiosis1, mod = "symbiont_tax_symbiosis") 
res_symbiont_tax_symbiosis1 <- left_join(res_symbiont_tax_symbiosis1, k_symbiont_tax_symbiosis, by =  c("name" = "symbiont_tax_symbiosis"))  %>% left_join(pred_symbiont_tax_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiont_tax_symbiosis <- ggplot(data = res_symbiont_tax_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiont_tax_symbiosis)), 
                   aes(x= tanh(Zr), y = symbiont_tax_symbiosis, size = ((1/VZr) + 3), colour = symbiont_tax_symbiosis), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  # setting colours
  scale_color_manual(values =   c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertParasite"= colour_ls[8] )) +
  scale_fill_manual(values = c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertParasite"= colour_ls[8] )) +
  scale_y_discrete(labels = c("MicrobeMutualist"= "Microbe-\nMutualist", "MicrobeParasite"= "Microbe-\nParasite",  "PlantMutualist" = "Plant-\nMutualist", "PlantParasite"="Plant-\nParasite", "InvertMutualist" = "Invertebrate-\nMutualist",   "InvertParasite"= "Invertebrate-\nParasite",  "VertParasite"= "Vertebrate-\nParasite" )) +
  annotate('text', x = 0.93, y = 1:7 + 0.15, label= paste("italic(k)==", res_symbiont_tax_symbiosis1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
    # putting pictures in
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -1.1, xmax = -0.9, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_parasitism),xmin = -0.9, xmax = -0.7, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -1.1, xmax = -0.9, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -1.1, xmax = -0.9, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -1.1, xmax = -0.9, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_mutualism), xmin = -0.9, xmax = -0.7, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -1.1, xmax = -0.9, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_vertebrate_parasite), xmin = -1.1, xmax = -0.9, ymin = 6.6, ymax = 7.2) +
  annotation_custom(rasterGrob(image_parasitism), xmin = -0.9, xmax = -0.7, ymin = 6.6, ymax = 7.2) 

fig_symbiont_tax_symbiosis
```

**Figure S3.4:** An orchard plot showing group-wise means (the categorical variable `symbiont_tax_symbiosis`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.

Splitting symbiont taxonomy by mode of symbiosis revealed much less variation, except for higher congruence exhibited by cophylogenies involving a plant symbiont (instances of which are relatively rare), and the finding that cophylogenies involving a microbial mutualist symbiont are slightly more congruent than the remaining categories.


#### The combined effect of host and symbiont taxa

```{r}
# reordering
dat$host_symbiont_tax <- factor(dat$host_symbiont_tax, 
                                     levels = c("MicrobeInvert", "MicrobeMicrobe", "MicrobePlant","PlantInvert", "PlantMicrobe", "InvertInvert", "InvertMicrobe", "InvertPlant", "VertInvert", "VertMicrobe", "VertVert"))

# meta-regression: multiple intercepts
mr_host_symbiont_tax1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_symbiont_tax - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$host_symbiont_tax)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_symbiont_tax, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_host_symbiont_tax <- map(level_names[-length(level_names)], run_rma)

```

#### Table S3.11
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_symbiont_tax`.  Note that `mu` means the group mean while `beta` represents the contrast between two groups in the Unit column.
```{r}
# getting marginal R2
r2_host_symbiont_tax1 <- R2(mr_host_symbiont_tax1)

# getting estimates
res_host_symbiont_tax1 <- get_est(mr_host_symbiont_tax1, mod = "host_symbiont_tax")
res_host_symbiont_tax <- map(mr_host_symbiont_tax, ~ get_est(.x, mod = "host_symbiont_tax"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:10)

# you need to flatten twice: first to make it a list and make it a vector
estimates <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()

lowerCLs <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()

upperCLs <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_host_symbiont_tax1$name), cont_gen(res_host_symbiont_tax1$name)),
  Estimate = c(res_host_symbiont_tax1$estimate, estimates),
  `Lower CI [0.025]` = c(res_host_symbiont_tax1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_host_symbiont_tax1$upperCL,upperCLs),
  `V[authors]` = c(mr_host_tax_symbiosis1$sigma2,  rep(NA, (11 + choose(11,2))- 1)),
  `R2` = c(r2_host_symbiont_tax1[1], rep(NA, (11 + choose(11, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```
#### Figure S3.5

```{r, fig.width=7, fig.height= 10}
# colour list
#colour_ls <- c("#000000", "#E69F00", "#56B4E9", "#009E73",  "#F0E422",  "#0072B2",  "#D55E00", "#CC79A7", "#00008B", "#8B0A50", "#54FF9F", "#999999")

# adding sample size (k) for each category
k_host_symbiont_tax <- dat %>% group_by(host_symbiont_tax) %>% count()
# getting estimates and predicitons
pred_host_symbiont_tax <- get_pred(mr_host_symbiont_tax1, mod = "host_symbiont_tax") 
res_host_symbiont_tax1 <- left_join(res_host_symbiont_tax1, k_host_symbiont_tax, by =  c("name" = "host_symbiont_tax"))  %>% left_join(pred_host_symbiont_tax)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_symbiont_tax <- ggplot(data = res_host_symbiont_tax1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_symbiont_tax)), 
                   aes(x= tanh(Zr), y = host_symbiont_tax, size = ((1/VZr) + 3), colour = host_symbiont_tax), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =  c("MicrobeInvert" = colour_ls[1],  "MicrobeMicrobe"= colour_ls[2], "MicrobePlant" = colour_ls[3], "PlantInvert" = colour_ls[4],"PlantMicrobe" = colour_ls[5], "InvertInvert"  = colour_ls[6],  "InvertMicrobe" = colour_ls[7], "InvertPlant" = colour_ls[8],"VertInvert"  = colour_ls[9], "VertMicrobe"= colour_ls[10],"VertVert"  = colour_ls[11])) +
  scale_fill_manual(values = c("MicrobeInvert" = colour_ls[1],  "MicrobeMicrobe"= colour_ls[2], "MicrobePlant" = colour_ls[3], "PlantInvert" = colour_ls[4],"PlantMicrobe" = colour_ls[5], "InvertInvert"  = colour_ls[6],  "InvertMicrobe" = colour_ls[7], "InvertPlant" = colour_ls[8],"VertInvert"  = colour_ls[9], "VertMicrobe"= colour_ls[10],"VertVert"  = colour_ls[11])) +
  scale_y_discrete(labels = c("MicrobeInvert" = "Microbe-\nInvertebrate",  "MicrobeMicrobe"= "Microbe-\nMicrobe", "MicrobePlant" = "Microbe-\nPlant", "PlantInvert" = "Plant-\nInvertebrate","PlantMicrobe" = "Plant-\nMicrobe", "InvertInvert"  = "Invertebrate\nInvertebrate",  "InvertMicrobe" = "Invertebrate-\nMicrobe", "InvertPlant" = "Invertebrate-\nPlant","VertInvert"  = "Vertebrate-\nInvertebrate", "VertMicrobe"= "Vertebrate-\nMicrobe", "VertVert"  = "Vertebrate-\nVertebrate")) +
  annotate('text', x = 0.93, y = 1:11 + 0.15, label= paste("italic(k)==", res_host_symbiont_tax1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlation)")), y = "", size = expression(paste(italic(n), " (# of species pairs)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) +
    # putting pictures in
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1.1, xmax = -0.9, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -0.9, xmax = -0.7, ymin = 0.6, ymax = 1.2) + 
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1.1, xmax = -0.9, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_microbe_parasite),xmin = -0.9, xmax = -0.7, ymin = 1.6, ymax = 2.2) +
  annotation_custom(rasterGrob(image_microbe_host), xmin = -1.1, xmax = -0.9, ymin = 2.6, ymax = 3.2) + 
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -0.9, xmax = -0.7, ymin = 2.6, ymax = 3.2) + 
  #
  annotation_custom(rasterGrob(image_plant_host), xmin = -1.1, xmax = -0.9, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -0.9, xmax = -0.7, ymin = 3.6, ymax = 4.2) +
  annotation_custom(rasterGrob(image_plant_host), xmin = -1.1, xmax = -0.9, ymin = 4.6, ymax = 5.2) +
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -0.9, xmax = -0.7, ymin = 4.6, ymax = 5.2) +
  #
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -0.9, xmax = -0.7, ymin = 5.6, ymax = 6.2) + 
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 6.6, ymax = 7.2) +
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -0.9, xmax = -0.7, ymin = 6.6, ymax = 7.2) +
  annotation_custom(rasterGrob(image_invertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 7.6, ymax = 8.2) +
  annotation_custom(rasterGrob(image_plant_parasite), xmin = -0.9, xmax = -0.7, ymin = 7.6, ymax = 8.2) +
  #
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 8.6, ymax = 9.2) + 
  annotation_custom(rasterGrob(image_invertebrate_parasite), xmin = -0.9, xmax = -0.7, ymin = 8.6, ymax = 9.2) + 
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 9.6, ymax = 10.2) +
  annotation_custom(rasterGrob(image_microbe_parasite), xmin = -0.9, xmax = -0.7, ymin = 9.6, ymax = 10.2) +
  annotation_custom(rasterGrob(image_vertebrate_host), xmin = -1.1, xmax = -0.9, ymin = 10.6, ymax = 11.2) +
  annotation_custom(rasterGrob(image_vertebrate_parasite), xmin = -0.9, xmax = -0.7, ymin = 10.6, ymax = 11.2)


fig_host_symbiont_tax
```

**Figure S3.5:** An orchard plot showing the group-wise means (the categorical variable `host_symbiont_tax`) with their 95% confidence intervals (thick lines) and 95% prediction intervals (thin lines), with observed effect sizes based on various sample sizes.

### Model selection (multi-predictor model)

Here we build the best model via an AICc based model selection method implemented in the R package `MuMin`[@barton2009mumin]. For the full model, we had 6 variables: `symbiosis`, `host_tax_broad`, `symbiont_tax_broad`, `mode_of_transmission_broad`, `endo_or_ecto`, & `log(host_range_link_ratio)`. We did not use `log(host_range_taxonomic_breadth)` as it is co-linear with `log(host_range_link_ratio)` and also many of the interaction terms. 

```{r}
# creates a new function to run in MuMIn
updated.rma.mv <- updateable(rma.mv)
#updated.rma.mv

# testing the new function 
# use method = "ML" so that we can compare AIC
mr_full <- updated.rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis + 
                         host_tax_broad +
                         symbiont_tax_broad +
                         mode_of_transmission_broad +
                         endo_or_ecto +
                         log(host_range_link_ratio),
                       test = "t",
                       random = ~ 1 | authors,
                       method="ML",
                       data = dat)

#=============================
### additional methods for "rma.mv" class (made by Kamil Barton)
### we need this to run model selection with rma.mv in MuMIn
#=============================
formula.rma.mv <- function (x, ...) return(eval(getCall(x)$mods))

makeArgs.rma.mv <-
  function (obj, termNames, comb, opt, ...) {
    ret <- MuMIn:::makeArgs.default(obj, termNames, comb, opt)
    names(ret)[1L] <- "mods"
    ret
  }

nobs.rma.mv <-
  function (object, ...)
    attr(logLik(object), "nall")

coefTable.rma.mv <- function (model, ...)
  MuMIn:::.makeCoefTable(model$b, model$se, coefNames = rownames(model$b))
#=============================

# testing dredge
#dredge(full.model, evaluate=F) # show all candidate models
# n = 32 model exisit
candidates <- dredge(mr_full)

# displays delta AICc <2
candidates_aic2 <- subset(candidates, delta < 2)

# model averaging
# it seems like models are using z values rather than t values (which will be OK)
mr_averaged_aic2 <- summary(model.avg(candidates,  delta < 2))

# relative importance of each predictor
importance <- importance(candidates)

# use REML if not for model comparision
model1 <- rma.mv(yi = Zr, V = VZr, mods = ~  host_tax_broad  + 
                   mode_of_transmission_broad + symbiosis, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)
model2 <- rma.mv(yi = Zr, V = VZr, mods = ~  host_tax_broad + 
                   mode_of_transmission_broad, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)
model3 <- rma.mv(yi = Zr, V = VZr, mods = ~  host_tax_broad + 
                   log(host_range_link_ratio) +
                   mode_of_transmission_broad + symbiosis, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)
model4 <- rma.mv(yi = Zr, V = VZr, mods = ~  host_tax_broad +
                    log(host_range_link_ratio) + 
                   mode_of_transmission_broad, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)
```

#### Table 3.12
The top 4 models (out of 32 possible models) within the $\Delta$AIC difference of 2, and which 6 variables: `symbiosis`, `host_tax_broad`, `symbiont_tax_broad`, `mode_of_transmission_broad`, `endo_or_ecto`, & `log(host_range_link_ratio)` were included (indicated by $+$); model weights (for the 2 models) and the sum of weights for each of the variables (from the 32 models) are included. 

```{r}
# creating a table
tibble(
  `Model (variable weight)` = c("Model1", "Model2", "Model3", "Model4","(Sum of weights)"),
  transmission = c(if_else(candidates_aic2$mode_of_transmission_broad == "+", "$+$", "NA"),round(importance[1],3) ),
  host_tax = c(if_else(candidates_aic2$host_tax_broad== "+", "$+$", "NA"),round(importance[2], 3)),
  symbiosis =  c(if_else(candidates_aic2$symbiosis== "+", "$+$", "NA"),round(importance[3], 3)),
  `host_range` = c(if_else(candidates_aic2$`log(host_range_link_ratio)` >= 0, "$+$", "NA"),round(importance[4], 3)),
  symbiont_tax = c(if_else(candidates_aic2$symbiont_tax_broad== "+", "$+$", "NA"),round(importance[5], 3)),
  endo_or_ecto = c(if_else(candidates_aic2$endo_or_ecto== "+", "$+$", "NA"),round(importance[6], 3)),
  delta_AICc = c(candidates_aic2$delta, NA),
  Weight = c(candidates_aic2$weight, NA)) %>% 
  kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

#### Model averaging

#### Table 3.13
The average estimates for regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the 2 best meta-regression models. Note that `mu` shows the overall value at the intercept while `beta` represents the contrast (or slope) between two groups in the Unit column.
```{r}

# getting averaged R2 and variance components not provided by the MuMIn package
average_sigma2 <- weighted.mean(x = c(model1$sigma2, model2$sigma2, model3$sigma2, model4$sigma2), w = candidates_aic2$weight)
average_R2 <- weighted.mean(x = c(R2(model1)[1], R2(model2)[1], R2(model3)[1], R2(model4)[1]) , w = candidates_aic2$weight)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutualist)",
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", 
                     "host_range","both-horizontal", "both-vertical",
                     "Mutualist-Parasite"),
  Estimate = mr_averaged_aic2$coefmat.full[,1],
  `Lower CI [0.025]` =  mr_averaged_aic2$coefmat.full[,1] - mr_averaged_aic2$coefmat.full[,2]*qnorm(0.975),
  `Upper CI  [0.975]` =  mr_averaged_aic2$coefmat.full[,1] + mr_averaged_aic2$coefmat.full[,2]*qnorm(0.975),
  `V[authors]` = c(average_sigma2, rep(NA,7)),
  `R2` = c(average_R2, rep(NA,7))) %>% 
  kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

## Appendix S4: Publication Bias Analysis

Here, we conducted 3 kinds of publication bias analyses: 1) contour-enhanced funnel plots [@peters2008contour] of residuals [@egger1997bias; @nakagawa2012methodological], 2) a type of Egger regression [@egger1997bias; @moreno2009assessment], and 3) a regression-based time-lag bias test [@nakagawa2012methodological]. 

### Funnel plot 

A normal funnel plot assumes homogeneity (i.e., *I*^2^ = 0). Therefore, we controlled for important moderators (i.e., `mode_of_transmission_broad`, `host_tax_broad`, `log(host_range_link_ratio)`, & `symbiosis`).

#### Residual funnel plot 1

We do not observe normal skewness in our enhanced-counter funnel plot (**Supplementary Figure 5**). This funnel asymmetry seems different from one caused by publication bias[@peters2008contour]; we do not expect a "hollow" in the region with high precision or i.e. inverse standard error (2.4-4) and relative high effect sizes (*Zr* = 0.5-1.0).  The funnel asymmetry is mainly caused by the boundary created by the number of randomizations (see the "Sensitivity Analysis" section where we deal with this skewness).

#### Figure 5a
```{r}
# 
res_funnel_plot <- rma.mv(yi = Zr, V = VZr, 
                               mods = ~ mode_of_transmission_broad +
                                 host_tax_broad + log(host_range_link_ratio) +
                                 symbiosis, 
                               random = ~ 1 | authors, data = dat)

funnel(res_funnel_plot, yaxis = "seinv", level=c(90, 95, 99), 
       xlim  = c(-3, 4), ylim = c(0.9, 5.2), xlab = "Residuals (correlation)", ylab = "Precision (1/SE)",
       shade=c("white", "gray55", "gray75"), 
       refline=0, legend=TRUE)
```

**Figure 5a:** A residual funnel plot from the meta-regression model with `mode_of_transmission_broad`, `host_tax_broad`, & `symbiosis`; 'residual value' is on *Zr* and 'inverse standard error' is precision `1/sqrt(VZr)`.


#### Residual funnel plot 2

Further, Egger regression analyses (see below) showed that `sqrt(VZr)` (sampling errors [SE] for effect sizes) accounts for much heterogeneity, so we added that to our model. The funnel asymmetry we see in **Supplementary Figure 6** (if any) is much less severe than that in **Supplementary Figure 5**. 

#### Figure 5b
```{r}
# 
res_funnel_plot2 <- rma.mv(yi = Zr, V = VZr, 
                               mods = ~ sqrt(VZr) +
                                mode_of_transmission_broad +
                                host_tax_broad +
                                log(host_range_link_ratio) +
                                symbiosis, 
                               random = ~ 1 | authors, data = dat)

funnel(res_funnel_plot2, yaxis = "seinv", level=c(90, 95, 99),
       xlim  = c(-3, 4), ylim = c(0.9, 5.2), xlab = "Residuals (correlation)", ylab = "Precision (1/SE)",
       shade=c("white", "gray55", "gray75"), refline=0, legend=TRUE)
```

**Figure 5b:** A residual funnel plot from the meta-regression model with `sqrt(VZr)`, `mode_of_transmission_broad`, `host_tax_broad`, `log(host_range_link_ratio)`, & `symbiosis`; 'residual value' is on *Zr* and 'inverse standard error' is precision `1/sqrt(VZr)`.

#### Putting together Figure 5

```{r, fig.width=14, fig.height= 6}
# building fig 3 using patchwork

par(mfrow = c(1,2))
funnel(res_funnel_plot, yaxis = "seinv", level=c(90, 95, 99), 
       xlim  = c(-3, 4), ylim = c(0.9, 5.2), xlab = "Residuals (correlation)", ylab = "Precision (1/SE)",
       shade=c("white", "gray55", "gray75"), 
       refline=0, legend=TRUE)
mtext("a", side = 3, cex = 1.5, line = 1, adj = 0)
funnel(res_funnel_plot2, yaxis = "seinv", level=c(90, 95, 99),
       xlim  = c(-3, 4), ylim = c(0.9, 5.2), xlab = "Residuals (correlation)", ylab = "Precision (1/SE)",
       shade=c("white", "gray55", "gray75"), refline=0, legend=TRUE)
mtext("b", side = 3, cex = 1.5, line = 1, adj = 0)

```

### Egger's regression

We applied Egger's regression to test whether the funnel asymmetries we observe in our funnel plots are statistically significant or not. 

#### Univariate Egger's regression

The test (or `sqrt(VZr)`) is significant. However, as mentioned above, this is due to the boundary created by the number of randomizations; this boundary can be seen in **Figure S4.1** below.  

```{r}
# 
egger_regression_uni <- rma.mv(yi = Zr, V = VZr, mods = ~ sqrt(VZr), random = ~ 1 | authors, data = dat)

```

#### Table S4.1
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `sqrt(VZr)`. 
```{r}
# getting marginal R2
r2_egger_regression_uni <- R2(egger_regression_uni)

# getting estimates: name does not work for slopes
res_egger_regression_uni <- get_est(egger_regression_uni, mod = "sqrt(VZr)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "sqrt(VZr)"),
  Estimate = c(res_egger_regression_uni$estimate),
  `Lower CI [0.025]` = c(res_egger_regression_uni$lowerCL),
  `Upper CI  [0.975]` = c(res_egger_regression_uni$upperCL),
  `V[authors]` = c(egger_regression_uni$sigma2, NA),
  `R2` = c(r2_egger_regression_uni[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```
#### Figure S4.1
```{r, fig.width=7, fig.height= 4}
pred_egger_regression_uni <-predict.rma(egger_regression_uni) 

# plotting

fit_egger_regression_uni <-  dat %>% 
  mutate(ymin = pred_egger_regression_uni$ci.lb, 
         ymax = pred_egger_regression_uni$ci.ub,
         ymin2 = pred_egger_regression_uni$cr.lb,
         ymax2 = pred_egger_regression_uni$cr.ub,
         pred = pred_egger_regression_uni$pred) %>% 
  ggplot(aes(x = sqrt(VZr), y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0.05, 0.45) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "sqrt(sampling variance)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_egger_regression_uni
```

**Figure S4.1:**
A bubble plot showing a predicted regression line for the continuous variable `sqrt(VZr)`, indicating 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines), with observed effect sizes based on various sample sizes. 


#### Multivariate Egger regression

We also conducted an Egger regression controlling other important moderators (i.e., `mode_of_transmission_broad`, `host_tax_broad`, `log(host_range_link_ratio)`, & `symbiosis`). After controlling for these variables, `sqrt(VZr)` stays significant.

```{r}
# 
egger_regression_mul <- rma.mv(yi = Zr, V = VZr, 
                               mods = ~ sqrt(VZr) +
                                 mode_of_transmission_broad +
                                 host_tax_broad +
                                 log(host_range_link_ratio) +
                                 symbiosis, 
                               random = ~ 1 | authors, data = dat)

```

#### Table S4.2
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `sqrt(VZr)`. 
```{r}
# getting marginal R2
r2_egger_regression_mul <- R2(egger_regression_mul)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutualist)", "sqrt(VZr)", "both-horizontal", "both-vertical", 
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", "host_range", "Mutualist-Parasite"),
  Estimate = c(egger_regression_mul$b),
  `Lower CI [0.025]` = c(egger_regression_mul$ci.lb),
  `Upper CI  [0.975]` = c(egger_regression_mul$ci.ub),
  `V[authors]` = c(egger_regression_mul$sigma2, rep(NA,8)),
  `R2` = c(r2_egger_regression_mul[1], rep(NA,8))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```
#### Figure S4.2
```{r, fig.width=7, fig.height= 4}
pred_egger_regression_mul <-predict.rma(egger_regression_mul) 

# plotting

fit_egger_regression_mul <-  dat %>% 
  filter(!is.na(mode_of_transmission_broad) & !is.na(host_tax_broad) & !is.na(symbiosis) & !is.na(host_range_link_ratio))  %>% # getting ride of NA values
  mutate(ymin = pred_egger_regression_mul$ci.lb, 
         ymax = pred_egger_regression_mul$ci.ub,
         ymin2 = pred_egger_regression_mul$cr.lb,
         ymax2 = pred_egger_regression_mul$cr.ub,
         pred = pred_egger_regression_mul$pred) %>% 
  ggplot(aes(x = sqrt(VZr), y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0.05, 0.45) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "sqrt(sampling variance)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_egger_regression_mul
```

**Figure S4.2:**
A bubble plot showing a predicted loess line for the continuous variable `sqrt(VZr)` (given the values of the other 3 variables in the model), with their 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines) with observed effect sizes based on various sample sizes. Note that the lines are not linear as these are based on multivariate predictions of the data points. 

### Time-lag bias

We do not find any evidence of a time-lag effect (a decline in the magnitude of the effect over time) in either the univariate or multivariate models (**Figure S4.X** and **Figure S4.X**).

#### Univariate time-lag bias
```{r}
# 
time_lag_effect_uni <- rma.mv(yi = Zr, V = VZr, mods = ~ year, random = ~ 1 | authors, data = dat)

```

#### Table S4.3
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `year`. 
```{r}
# getting marginal R2
r2_time_lag_effect_uni <- R2(time_lag_effect_uni)

# getting estimates: name does not work for slopes
res_time_lag_effect_uni <- get_est(time_lag_effect_uni, mod = "year")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "Year"),
  Estimate = c(res_time_lag_effect_uni$estimate),
  `Lower CI [0.025]` = c(res_time_lag_effect_uni$lowerCL),
  `Upper CI  [0.975]` = c(res_time_lag_effect_uni$upperCL),
  `V[authors]` = c(time_lag_effect_uni$sigma2, NA),
  `R2` = c(r2_time_lag_effect_uni[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```
#### Figure S4.3
```{r, fig.width=7, fig.height= 4}
pred_time_lag_effect_uni <-predict.rma(time_lag_effect_uni) 

# plotting

fit_time_lag_effect <-  dat %>% 
  mutate(ymin = pred_time_lag_effect_uni$ci.lb, 
         ymax = pred_time_lag_effect_uni$ci.ub,
         ymin2 = pred_time_lag_effect_uni$cr.lb,
         ymax2 = pred_time_lag_effect_uni$cr.ub,
         pred = pred_time_lag_effect_uni$pred) %>% 
  ggplot(aes(x = year, y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(1994,2019) +
  scale_x_continuous(breaks = c(1995, 2000, 2005, 2010, 2015, 2020)) + 
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "Year", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_time_lag_effect
```

**Figure S4.3:** A bubble plot showing a predicted regression line for the contenious variable `year`, indicating 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines), with observed effect sizes based on various sample sizes. 

#### Multivariate time-lag bias
```{r}
# 
time_lag_effect_mul <- rma.mv(yi = Zr, V = VZr, 
                              mods = ~ year +
                                mode_of_transmission_broad +
                                host_tax_broad +
                                log(host_range_link_ratio) +
                                symbiosis,
                              random = ~ 1 | authors, data = dat)

```

#### Table S4.4
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the meta-regression with `year`. 
```{r}
# getting marginal R2
r2_time_lag_effect_mul <- R2(time_lag_effect_mul)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutualist)", "Year", "both-horizontal", "both-vertical", 
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", "host_range", "Mutualist-Parasite"),
  Estimate = c(time_lag_effect_mul$b),
  `Lower CI [0.025]` = c(time_lag_effect_mul$ci.lb),
  `Upper CI  [0.975]` = c(time_lag_effect_mul$ci.ub),
  `V[authors]` = c(time_lag_effect_mul$sigma2, rep(NA,8)),
  `R2` = c(r2_time_lag_effect_mul[1], rep(NA,8))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

#### Figure S4.4
```{r, fig.width=7, fig.height= 4}
pred_time_lag_effect_mul <-predict.rma(time_lag_effect_mul) 

# plotting
fit_time_lag_effect_mul <-  dat %>% 
  filter(!is.na(mode_of_transmission_broad) & !is.na(host_tax_broad) & !is.na(symbiosis) & !is.na(host_range_link_ratio))  %>% 
  mutate(ymin = pred_time_lag_effect_mul$ci.lb, 
         ymax = pred_time_lag_effect_mul$ci.ub,
         ymin2 = pred_time_lag_effect_mul$cr.lb,
         ymax2 = pred_time_lag_effect_mul$cr.ub,
         pred = pred_time_lag_effect_mul$pred) %>% 
  ggplot(aes(x = year, y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(1994,2019) +
  scale_x_continuous(breaks = c(1995, 2000, 2005, 2010, 2015, 2020)) + 
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "Year", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species pairs)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_time_lag_effect_mul
```

**Figure S4.4:** A bubble plot showing a predicted loess line for the continuous variable `year` (given the values of the other 3 variables in the model), indicating 95% confidence regions (orange dotted lines) and 95% prediction regions (blue dotted lines) with observed effect sizes based on various sample sizes. Note that the lines are not linear as these are based on multivariate predictions of the data points. 

## Appendix S5: Sensitivity Analysis

The funnel plots above identified the issue of upper bounds for the effect size given a sample size (an upper limit of a *p* value given the number of randomizations). This boundary would influence our estimates of mean effect sizes and contrasts (i.e., comparing two groups), often making our overall conclusions too conservative. To demonstrate this, we conducted two analyses to show: 1)  the number of randomizations (`log(no_randomizations)`) do not differ between categories in the 3 important categorical moderators (`mode_of_transmission_broad`, `host_tax_broad`, & `symbiosis`), and, 2) categories with high effect sizes would include "bounded" effect sizes (i.e., from *p* = 0.01, 0.001, or 0.0001; `limit_reached`) in the 3 moderators.

### Sensitivity test 1: the number of randomizations

Below, we showed that none of the categories have significantly different numbers of randomizations in all `mode_of_transmission_broad`, `host_tax_broad`, & `symbiosis`. 
 
#### The type of symbiosis: parasitism vs. mutualism

```{r}
# 233 --- Yes = 74 (0.3175966%); No = 159

# symbiosis
# multiple intercepts
sa_random_symbiosis1<-lmer(log(no_randomizations) ~ symbiosis - 1 + (1 | authors), data = dat)
#contrast
sa_random_symbiosis2<-lmer(log(no_randomizations) ~ symbiosis + (1 | authors), data = dat)

```

#### Table S5.1
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2), from the regression with `symbiosis` on `log(no_randomizations)`. 

```{r}
# getting marginal R2
r2_sa_random_symbiosis <- r2_nakagawa(sa_random_symbiosis1)

# getting estimates

res_sa_random_symbiosis<- tibble(estiamte = c(fixef(sa_random_symbiosis1), fixef(sa_random_symbiosis2)[2]))

ci_sa_random_symbiosis1<-confint(sa_random_symbiosis1)
ci_sa_random_symbiosis2<-confint(sa_random_symbiosis2)
res_sa_random_symbiosis %<>% mutate(lowerCL = c(ci_sa_random_symbiosis1[3:4,1], ci_sa_random_symbiosis2[4,1]))
res_sa_random_symbiosis %<>% mutate(upperCL = c(ci_sa_random_symbiosis1[3:4,2], ci_sa_random_symbiosis2[4,2]))
           
# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiosis1$name), cont_gen(res_symbiosis1$name)),
  Estimate = res_sa_random_symbiosis$estiamte,
  `Lower CI [0.025]` = res_sa_random_symbiosis$lowerCL,
  `Upper CI  [0.975]` = res_sa_random_symbiosis$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_random_symbiosis1)$author,"stddev")^2,  rep(NA, 2)),
  `V[residuals]` =c(attr(VarCorr(sa_random_symbiosis1),"sc")^2, rep(NA, 2)),
  `R2` = c(r2_sa_random_symbiosis$R2_marginal, rep(NA, 2))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```
#### The effect of host taxa
```{r}
# host_tax_broad
# mutiple intercepts
sa_random_host_tax_broad1<-lmer(log(no_randomizations) ~ host_tax_broad - 1 + 
                                (1 | authors), data = dat)
# contrast 1
sa_random_host_tax_broad2<-lmer(log(no_randomizations) ~ host_tax_broad +
                               (1 | authors), data = dat)
# contrast 2
sa_random_host_tax_broad3<-lmer(log(no_randomizations) ~ relevel(host_tax_broad, ref = "Plant") +
                               (1 | authors), data = dat)

# contrast 3
sa_random_host_tax_broad4<-lmer(log(no_randomizations) ~ relevel(host_tax_broad, ref = "Invert") + 
                                  (1 | authors), data = dat)
```

#### Table S5.2
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the regression with `host_tax_broad` on `log(no_randomizations)`. 

```{r}
# getting marginal R2
r2_sa_random_host_tax_broad <- r2_nakagawa(sa_random_host_tax_broad1)

# getting estimates
res_sa_random_host_tax_broad <- tibble(estiamte = c(fixef(sa_random_host_tax_broad1), 
                                                    fixef(sa_random_host_tax_broad2)[2:4],
                                                    fixef(sa_random_host_tax_broad3)[3:4],
                                                    fixef(sa_random_host_tax_broad4)[4])) 
  
ci_sa_random_host_tax_broad1<-confint(sa_random_host_tax_broad1)
ci_sa_random_host_tax_broad2<-confint(sa_random_host_tax_broad2)
ci_sa_random_host_tax_broad3<-confint(sa_random_host_tax_broad3)
ci_sa_random_host_tax_broad4<-confint(sa_random_host_tax_broad4)
res_sa_random_host_tax_broad %<>% mutate(lowerCL = c(ci_sa_random_host_tax_broad1[3:6,1], 
                                                ci_sa_random_host_tax_broad2[4:6,1],
                                                ci_sa_random_host_tax_broad3[5:6,1],
                                                ci_sa_random_host_tax_broad4[6,1]))
res_sa_random_host_tax_broad %<>% mutate(upperCL = c(ci_sa_random_host_tax_broad1[3:6,2], 
                                                ci_sa_random_host_tax_broad2[4:6,2],
                                                ci_sa_random_host_tax_broad3[5:6,2],
                                                ci_sa_random_host_tax_broad4[6,2]))
# creating a table
tibble(
  `Fixed effect` =  c(as.character(res_symbiont_tax_broad1$name), cont_gen(res_symbiont_tax_broad1$name)), # done
  Estimate = res_sa_random_host_tax_broad$estiamte,
  `Lower CI [0.025]` = res_sa_random_host_tax_broad$lowerCL,
  `Upper CI  [0.975]` = res_sa_random_host_tax_broad$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_random_host_tax_broad1)$author,"stddev")^2,  rep(NA, 9)),
  `V[residuals]` =c(attr(VarCorr(sa_random_host_tax_broad1),"sc")^2, rep(NA, 9)),
  `R2` = c(r2_sa_random_host_tax_broad$R2_marginal, rep(NA, 9))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

#### The effect of the mode of transmission

```{r}
# mode_of_transmission_broad

sa_random_mode_of_transmission_broad1<-lmer(log(no_randomizations) ~ mode_of_transmission_broad - 1 + 
                                              (1 | authors), data = dat)


# contrast 1
sa_random_mode_of_transmission_broad2<-lmer(log(no_randomizations) ~ mode_of_transmission_broad + 
                                             (1 | authors), data = dat)

# contrast 2
sa_random_mode_of_transmission_broad3 <- lmer(log(no_randomizations) ~ relevel(mode_of_transmission_broad, ref = "vertical") + 
                                             (1 | authors), data = dat)
```

#### Table S5.3
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the regression with `mode_of_transmission_broad` on `log(no_randomizations)`. 

```{r}
# getting marginal R2
r2_sa_random_mode_of_transmission_broad <- r2_nakagawa(sa_random_mode_of_transmission_broad1)

# getting estimates
res_sa_random_mode_of_transmission_broad <- tibble(estiamte = c(fixef(sa_random_mode_of_transmission_broad1), 
                                                    fixef(sa_random_mode_of_transmission_broad2)[2:3],
                                                    fixef(sa_random_mode_of_transmission_broad3)[3])) 
  
ci_sa_random_mode_of_transmission_broad1<-confint(sa_random_mode_of_transmission_broad1)
ci_sa_random_mode_of_transmission_broad2<-confint(sa_random_mode_of_transmission_broad2)
ci_sa_random_mode_of_transmission_broad3<-confint(sa_random_mode_of_transmission_broad3)
res_sa_random_mode_of_transmission_broad %<>% mutate(lowerCL = c(ci_sa_random_mode_of_transmission_broad1[3:5,1], 
                                                ci_sa_random_mode_of_transmission_broad2[4:5,1],
                                                ci_sa_random_mode_of_transmission_broad3[5,1]))
res_sa_random_mode_of_transmission_broad %<>% mutate(upperCL = c(ci_sa_random_mode_of_transmission_broad1[3:5,2], 
                                                ci_sa_random_mode_of_transmission_broad2[4:5,2],
                                                ci_sa_random_mode_of_transmission_broad3[5,2]))
# creating a table
tibble(
  `Fixed effect` = c(as.character(res_mode_of_transmission_broad1$name), cont_gen(res_mode_of_transmission_broad1$name)),
  Estimate = res_sa_random_mode_of_transmission_broad$estiamte,
  `Lower CI [0.025]` = res_sa_random_mode_of_transmission_broad$lowerCL,
  `Upper CI  [0.975]` = res_sa_random_mode_of_transmission_broad$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_random_mode_of_transmission_broad1)$author,"stddev")^2,  rep(NA, 5)),
  `V[residuals]` =c(attr(VarCorr(sa_random_mode_of_transmission_broad1),"sc")^2, rep(NA, 5)),
  `R2` = c(r2_sa_random_mode_of_transmission_broad$R2_marginal, rep(NA, 5))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

### Sensitivity test 2: reaching the limits

Below, we show that categories with higher effect sizes were more likely to have "bounded" effect sizes (`limit_reached`) in all `mode_of_transmission_broad`, `host_tax_broad`, & `symbiosis`. This indicates that the higher the estimate of mean effect size is, the more underestimated the mean effect size is. This is true for differences between two categories; the larger the difference between the two, the more underestimated the difference is. 


#### The type of symbiosis: parasitism vs. mutualism

#### Table S5.4
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the regression with `symbiosis` on `limit_reached` (compare the effect estimates in **Table S3.1** with the corresponding values in this table below; their ranking in estimation should usually match).

```{r}
# symbiosis
sa_limit_symbiosis1 <- glmer(limit_reached ~ symbiosis - 1 + (1 | authors), family = "binomial", data = dat)

# getting marginal R2
r2_sa_limit_symbiosis <- r2_nakagawa(sa_limit_symbiosis1)

# getting estimates
res_sa_limit_symbiosis <- tibble(estiamte = fixef(sa_limit_symbiosis1))
  
res_sa_limit_symbiosis %<>% mutate(lowerCL = (tidy(sa_limit_symbiosis1)$estimate[-3] -
                                                       tidy(sa_limit_symbiosis1)$std.error[-3]*qnorm(0.975)))
res_sa_limit_symbiosis %<>% mutate(upperCL = (tidy(sa_limit_symbiosis1)$estimate[-3] +
                                                       tidy(sa_limit_symbiosis1)$std.error[-3]*qnorm(0.975)))
# creating a table
tibble(
  `Fixed effect` = as.character(res_symbiosis1$name),
  Estimate = res_sa_limit_symbiosis$estiamte,
  `Lower CI [0.025]` = res_sa_limit_symbiosis$lowerCL,
  `Upper CI  [0.975]` = res_sa_limit_symbiosis$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_limit_symbiosis1)$author,"stddev")^2,  rep(NA, 1)),
  `R2` = c(r2_sa_limit_symbiosis$R2_marginal, rep(NA, 1))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 

#t_symbiosis

```
#### Table S3.1* (for comparision)
In both tables, `mutualist` has higher estimates (i.e, `mutualist` rearched the ceiling more often) 

```{r}
t_symbiosis %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```


#### The effect of host taxa

#### Table S5.5
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the regression with `host_tax_broad` on `limit_reached`  (compare the effect estimates in **Table S3.2** with the corresponding values in this table below; their ranking in estimation should usually match).

```{r}
# host_tax_broad
sa_limit_host_tax_broad1<-glmer(limit_reached ~ host_tax_broad - 1  + (1 | authors), family = "binomial", data = dat)

# getting marginal R2
r2_sa_limit_host_tax_broad <- r2_nakagawa(sa_limit_host_tax_broad1)

# getting estimates
res_sa_limit_host_tax_broad <- tibble(estiamte = fixef(sa_limit_host_tax_broad1))
  
res_sa_limit_host_tax_broad %<>% mutate(lowerCL = (tidy(sa_limit_host_tax_broad1)$estimate[-5] -
                                                       tidy(sa_limit_host_tax_broad1)$std.error[-5]*qnorm(0.975)))
res_sa_limit_host_tax_broad %<>% mutate(upperCL = (tidy(sa_limit_host_tax_broad1)$estimate[-5] +
                                                       tidy(sa_limit_host_tax_broad1)$std.error[-5]*qnorm(0.975)))
# creating a table
tibble(
  `Fixed effect` = as.character(res_symbiont_tax_broad1$name),
  Estimate = res_sa_limit_host_tax_broad$estiamte,
  `Lower CI [0.025]` = res_sa_limit_host_tax_broad$lowerCL,
  `Upper CI  [0.975]` = res_sa_limit_host_tax_broad$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_limit_host_tax_broad1)$author,"stddev")^2,  rep(NA, 3)),
  `R2` = c(r2_sa_limit_host_tax_broad$R2_marginal, rep(NA, 3))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 

# t_host_tax

```
#### Table S3.2* (for comparision)

```{r}
t_host_tax %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

#### The effect of the mode of transmission

#### Table S5.6
Regression coefficients (estimate), 95% confidence intervals (CIs), variance components (V) and variance explained, *R*^2^~[marginal]~ (R2) from the regression with `mode_of_transmission_broad` on `limit_reached`  (compare the effect estimates in **Table S3.7** with the corresponding values in this table below; their ranking in estimation should usually match).

```{r}
# mode_of_transmission_broad
sa_limit_mode_of_transmission_broad1 <- glmer(limit_reached ~ mode_of_transmission_broad - 1 + (1 | authors), family = "binomial", data = dat)

# getting marginal R2
r2_sa_limit_mode_of_transmission_broad <- r2_nakagawa(sa_limit_mode_of_transmission_broad1)

# getting estimates
res_sa_limit_mode_of_transmission_broad <- tibble(estiamte = fixef(sa_limit_mode_of_transmission_broad1))
  
res_sa_limit_mode_of_transmission_broad %<>% mutate(lowerCL = (tidy(sa_limit_mode_of_transmission_broad1)$estimate[-4] -
                                                       tidy(sa_limit_mode_of_transmission_broad1)$std.error[-4]*qnorm(0.975)))
res_sa_limit_mode_of_transmission_broad %<>% mutate(upperCL = (tidy(sa_limit_mode_of_transmission_broad1)$estimate[-4] +
                                                       tidy(sa_limit_mode_of_transmission_broad1)$std.error[-4]*qnorm(0.975)))
# creating a table
tibble(
  `Fixed effect` = as.character(res_mode_of_transmission_broad1$name),
  Estimate = res_sa_limit_mode_of_transmission_broad$estiamte,
  `Lower CI [0.025]` = res_sa_limit_mode_of_transmission_broad$lowerCL,
  `Upper CI  [0.975]` = res_sa_limit_mode_of_transmission_broad$upperCL,
  `V[authors]` = c(attr(VarCorr(sa_limit_mode_of_transmission_broad1)$author,"stddev")^2,  rep(NA, 2)),
  `R2` = c(r2_sa_limit_mode_of_transmission_broad$R2_marginal, rep(NA, 2))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 

# t_transmission
```

#### Table S3.7* (for comparision)

```{r}
t_transmission %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

## Acknowledgements

Many coding materials have been borrowed from these papers [@cally2019meta; @odea2018developmental]. We thank Losia Lagisz for preparing small icons and cartoons used in the figures. 

## R Session Information

```{r}
# pander for making it look nicer
sessionInfo() %>% pander()
```

## References