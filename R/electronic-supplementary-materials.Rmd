---
title: "Testing the generality of host-symbiont cophylogeny"
author: "Alexander Hayward, Robert Poulin & Shinichi Nakagawa"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_download: true
    code_folding: hide
    depth: 4
    number_sections: no
    theme:  cosmo # “default”, “cerulean”, “journal”, “flatly”, “darkly”, “readable”, “spacelab”, “united”, “cosmo”, “lumen”, “paper”, “sandstone”, “simplex”, “yeti”
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
subtitle: Electronic Supplementary Material
bibliography: references.bib
---

<!--- Try to add references for this!!!! --->

```{r setup, include = FALSE}
#kniter seetting
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE, # no warnings
cache = TRUE,# Cacheing to save time when kniting
tidy = TRUE
#fig.width = 9
)

# clearning up
rm(list=ls())
```

## Setups

### Loading pacakges and custum functions

```{r}
# loading packages
pacman::p_load(tidyverse, # tidy family and related pacakges below
               kableExtra, 
               gridExtra, 
               purrr,
               magrittr, # extending piping
               pander,   # nice tables
               metafor,  # package for meta-analysis
               MCMCglmm,  # Bayeisan mixed model package
               ggbeeswarm, # making bee-swarm plots possible
               plotly,     # interactive plots using ggplot2
               MuMIn,  # multi-model inference
               lme4,   # lmm & glmm (models)
               broom.mixed, # getting estimates from lmer + glmer objects
               performance # getting R2 from lmer + glmer objects
               #mi,      # missing data analysis
               #betareg   # dependance of the above
)

# getting functions 
source("../R/ESM_functions.R", chdir = TRUE)

```

#### Custum functions

NOTE!!!
We have XX custum functions: ....... 

## Supplementary Methods and Materials

### XXXX1

### XXXX2

## The Cophylogeny Dataset

### Table of the dataset

Below is the dataset used for our meta-analysis follwed by explanations of 24 variables original collected (not all varaibles were used for our analyses; variables which were neither 'directly' nor 'indirectly' used in our analyses are indicated by *)

```{r}
# getting the data and formating some variables (turning chraracter vectors to factors)
# read the difference between factr() and as.factor() <https://stackoverflow.com/questions/39279238/why-use-as-factor-instead-of-just-factor>
# full_data <- read.csv("../data/2019-04-04-source-data-dat.csv", na = "NA", fileEncoding="UTF-8") %>%
#  mutate_if(is.character, as.factor)
full_data <- read_csv("../data/2019-23-07-source-data-dat.csv", na = "NA") %>% 
   mutate_if(is.character, as.factor)

# making a scrollable table
kable(full_data, "html") %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")
```

A. __authors__: The authors of the study and the date (citation form).

B. __year__: Year of publication of the study.

C. __host_tax_broad__:	Separation of the host group according to broader taxonomic units (e.g. vertebrate, invertebrate, microbe, plant).

D. __host_tax_fine__*:	Separation of the host group according to narrower taxonomic units (e.g. fish, tetrapod, bird, invertebrate, protist, bacterium, plant, fungus).

E. __symbiont_tax_broad__:	Separation of the symbiont group according to broader taxonomic units (e.g. vertebrate, invertebrate, microbe, plant).

F. __symbiont_tax_fine__*:	Separation of the symbiont group according to narrower taxonomic units (e.g. invertebrate, protist, virus, bacterium, fungus, plant, bird).

G. __symbiont_euk__*:	Whether the symbiont is eukaryotic (state ='yes'), or prokaryotic (state='no').

H. __symbiosis__:	The type of symbiont (e.g. parasite or mutualist). For this we followed the definition used by the authors of the study.

I. __endo_or_ecto__:	Whether the symbiont lives outside the host (i.e. is an ectosymbiont), or inside the host (i.e. is an endosymbiont).

J. __mode_of_transmission_broad__:	Whether the symbiont is transmitted vertically, horizontally, or both. For this, we followed the route of transmission specified by the authors of the study

K. __mode_of_transmission_fine__*:	A finer-scale description of the mode of transmission of the symbiont (e.g. contact, vector, bodily fluid, vertical, trophic).

L. __symbiont__*:	Shorthand description of the type of symbiont.

M. __Visiting_symbiont?__*	Whether the symbiont is resident on the host (resident), or makes visits to the host or hosts (visitor).

N. __host_tips_linked__:	The number of individual host taxa included in the cophylogenetic analysis.

O. __host_tips_linked_corrected__	The same measure as for column N, 'host_tips_linked', but reduced to only include one member of each host species. This is included because some authors include multiple individuals of the same host species. Without correction, this artificially increases the apparent number of host species included in the study.

P. __host_genera__:	A count of the number of host genera included in the cophylogenetic analysis

Q. __total_host_symbioint_links__	The total number of links between host and symbiont taxa recorded in a study. If all symbionts were strict specialists, this would equal the number of symbionts included in the study. However, because symbionts are often associated with more than one host, this value is often higher than the total number of symbionts included in the study.

R. __host_range_link_ratio__:	An estimation of symbiont host specificity, calculated by dividing the total number of links between hosts and symbionts (i.e. 'total_host_symbiont_links', column Q), by the total number of symbionts included in the study (i.e. 'symbiont_tips_linked', column T).

S. __host_range_taxonomic_breadth__:	An alternative estimation of symbiont host specificity, calculated by first summing the number of host taxonomic ranks linked to each symbiont (i.e. single host species = 1, multiple host species in the same genera = 2, multiple host genera = 3, multiple host familes = 4, multiple host orders = 5), and dividing by the total number of symbionts included in the study (i.e. 'symbiont_tips_linked', column T)

T. __symbiont_tips_linked__	The number of individual symbiont taxa included in the cophylogenetic analysis.

U. __symbiont_genera__:	A count of the number of symbiont genera included in the cophylogenetic analysis.

V. __no_randomizations__:	The number of phylogenetic randomizations performed during the cophylogenetic analysis.

W. __p_value__:	The p-value reported for the cophylogenetic analysis, representing the likelihood that host and symbtion phylogenies display cospeciation.

X. __method__:	Whether TreeMap or Parafit was used to obtain co-divergence or a p value.

### Table of sample sizes

We present the number of sample size for two sepreate methods: TreeMap and Parafit (and combined) for effect sizes, papers and different levels of categorical varaibles (factors).   

```{r}
# selecting out variables, which we used for our analysis
dat <- full_data %>% select(-host_tax_fine, -symbiont_tax_fine, -symbiont_euk, -mode_of_transmission_fine, -symbiont, -`Visiting_symbiont?`)

# making a table of sample sizes for different variables
dat %>% group_by(method) %>% 
  summarise(
    `Effect sizes` = n(),
    Papers = n_distinct(authors),
    `Vertebrate hosts` = sum(host_tax_broad == "Vert", na.rm = T), # na.rm is important when NA exists
    `Invertebrate hosts` = sum(host_tax_broad == "Invert", na.rm = T),
    `Plant hosts`  = sum(host_tax_broad == "Plant", na.rm = T),
    `Microbe hosts` = sum(host_tax_broad == "Microbe", na.rm = T),
    `Vertebrate symbionts` = sum(symbiont_tax_broad  == "Vert", na.rm = T),
    `Invertebrate symbionts` = sum(symbiont_tax_broad  == "Invert", na.rm = T),
    `Plant symbionts`  = sum(symbiont_tax_broad  == "Plant", na.rm = T),
    `Microbe symbionts` = sum(symbiont_tax_broad  == "Microbe", na.rm = T),
    `Parastic relationships` = sum(symbiosis == "Parasite", na.rm = T),
    `Mutualistic relatioships` = sum(symbiosis == "Mutualist", na.rm = T),
    `Ecto-symbionts` = sum(endo_or_ecto  == "Ecto", na.rm = T),
    `Endo-symbionts` = sum(endo_or_ecto == "Endo", na.rm = T),
    `Ecto/endo-symbionts` = sum(endo_or_ecto == "Endo/Ecto", na.rm = T),
    `Horizontal transmission` = sum(mode_of_transmission_broad  == "horizontal", na.rm = T),
    `Vertical transmission` = sum(mode_of_transmission_broad == "vertical", na.rm = T),
    `Horizontal/vertical-transmission` = sum(mode_of_transmission_broad == "both", na.rm = T)
  ) -> n_table1

# transposing the table and creating that table and adding a correct number of the papers for `Combined`
n_authors <- n_distinct(dat$authors) # the total number of papers
n_table2 <-t(n_table1[,-1])
colnames(n_table2) <- n_table1$method
n_table2 %>% as_tibble(rownames = "Number") %>% 
  mutate(Combined = Parafit + TreeMap, Combined = replace(Combined, 2, n_authors)) %>%  
  rename("Number of" = "Number", "Parafit (n)" = "Parafit", "TreeMap (n)" = "TreeMap",  "Combined (n)" = "Combined") %>% 
  kable() %>% kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "250px")
  #pander(split.cell = 40, split.table = Inf) # not as nice as kable
```
Note that for the numbers of papers do not add up (TreeMap + Parafit $\neq$ Combined) becuase `r sum(n_table2[2,]) - length(unique(dat$authors))`  papers used both TreeMap and Parafit methods (the term "papers" here is our variable `auhtors`)

### Missing data patterns

Here we have the number of missing data (cells) for all the varaibles used in the analysis below.

```{r}
# summaring missingness in our dataset
# funs(sum(is.na(.))) needs to be in funs as is.na has "." = each column
dat %>% summarise_all(~sum(is.na(.))) %>% # map(~sum(is.na(.)) # this is an alterantive way 
  t() %>% as_tibble(rownames = "Variable") %>% 
  rename("Number of missing data (n)" = "V1") %>% 
  #pander(split.cell = 40, split.table = Inf)
  kable() %>% kable_styling("striped", position = "left") %>%
  scroll_box(width = "60%", height = "250px")

# an alternative method using the mi package
#missing_data_tbl <- missing_data.frame(as.data.frame(data))
#show(missing_data_tbl) 
```

## Meta-analysis

### Calculating effect sizes

Here, we creatde our effect size (correlation coefficent *r* and its Fisher's z transformaiton *Zr*) from p values and associated sample sizes. We used the sum of `host_tips_linked_corrected` and `symbiont_tips_linked` as our sample size (i.e., the number of both host and symbiont species) for each effect size (an indicator of congruence). Also, we creat a column with unique ID for each observation (i.e. an observation level random effect), termed `observation`, which is required for the `rma.mv` function in `metafor`.

```{r}
dat %<>% 
  # getting sample size & observation level random effect
  mutate(., sample_size = host_tips_linked_corrected + symbiont_tips_linked, observation = factor(1:nrow(.)))  
# calcuating effect size 
# somehow it did not run by piping with above (not recognising the first aurgument)  
dat %<>% p_to_Zr(p_value, sample_size) 

# TODO
# some factor reordering required!!!
levels = c("small", "medium", "large")
```


### Meta-analytic model: testing Fahrenholz's rule

First, we checked what random effects should be put into the main model to do this we fitted two random effects, `authors` and `observation`; the former term was added to account for non-independence of effect sizes orginating from the same papers (i.e., `authors`). 

```{r, cache=TRUE}
# 2 random effects & model AIC 
# note that probably only base stuff works outside of main chunck so need to create AIC here
ma_test1 <- rma.mv(yi = Zr, 
                   V = VZr, 
                   random = list(~ 1 | authors, ~1|observation), 
                   data = dat)
aic1 <- AIC(ma_test1)

# 1 random effect & model AIC 
ma_test2 <- rma.mv(yi = Zr, 
                   V = VZr, 
                   random = ~ 1 | authors, 
                   data = dat)
aic2 <- AIC(ma_test2)
```

The model (`ma_test1`), which included both random factors, had a larger AIC value (`r round(aic1,2)`) than the model with only one random effect (`r round(aic2, 2)`) . This is becuase `observation` hardly accounted any variance (< 0.0001) compared to `authors` (`r round(ma_test1$sigma2[1], 4)`). Therefore, we only had `authors` as our random factor in subsquentb analyses.

We ran intercept models (meta-analyses) with 3 different datasets (`Parafit`, `TreeMap` and both combined; see the explantion of `method` above). Also, we note that we used adjustments for test statistics and confidence intervals (`test = "t"`), which is similar to (but not the same as) those proposed by Kanpp and Hartung (2003); probably this approch is a more conservative approach.

#### Running Multilevel Meta-analytic models with 3 datasets
```{r, cache=TRUE}
# think about making this into a tibble
# meta-analysis with Parafit
ma_parafit <- rma.mv(yi = Zr, 
                 V = VZr, 
                 random = ~ 1 | authors, 
                 test = "t",
                 subset = which(method == "TreeMap"),
                 data = dat)

# meta-analysis with TreeMap
ma_treemap <- rma.mv(yi = Zr, 
                 V = VZr, 
                 random = ~ 1 | authors, 
                 test = "t",
                 subset = which(method == "Parafit"),
                 data = dat)

# meta-analysis with all the data combined
ma_all <- rma.mv(yi = Zr, 
                 V = VZr, 
                 test = "t",
                 random = ~ 1 | authors, 
                 data = dat)
```

**Supplementary Table 1:**
Overall effects (meta-analytic means), 95% confidence intervals (CIs), variance components (V) and heterogeneity, *I*^2^ (I2) from `metafor` model using the 3 datasets (`Parafit`, `TreeMap` and both combined, or `All`). Note that in these models, *I*^2^~[total]~ = *I*^2^~[authors]~ (see Nakagawa & Santos 2012; REF - probably Senior as well?), as we only have one random factor. 
```{r}
# getting I2 for the models
# could use map()
i2_treemap <- I2(ma_treemap)
i2_parafit <- I2(ma_parafit)
i2_all <- I2(ma_all)
# creating a table
tibble(
  Dataset = c("Parafit", "TreeMap", "All"),
  `Overall mean (Zr)` = c(ma_parafit$b, ma_treemap$b, ma_all$b),
  `Lower CI [0.025]` = c(ma_parafit$ci.lb, ma_treemap$ci.lb, ma_all$ci.lb),
  `Upper C  [0.975]` = c(ma_parafit$ci.ub, ma_treemap$ci.ub, ma_all$ci.ub),
  `V[authors]` = c(ma_parafit$sigma2, ma_treemap$sigma2, ma_all$sigma2),
  `I2[total]` = c(i2_parafit[1], i2_treemap[1], i2_all[1]))%>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left")
```

These models gave all consistant results including heterogeneity. Given these results, we proceeded with only analysing the whole dataset (`All`) from this on.    

```{r,  fig.width=7, fig.height=2.5}
# creating a table of results
pred_ma <- get_pred(ma_all) 
effect_ma <- get_est(ma_all) %>% left_join(pred_ma) 

# creating a forest plot
fig_ma <- ggplot(data = effect_ma, aes(x = tanh(estimate), y = "Overall mean")) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat, aes(x= tanh(Zr), y = "Overall mean", size = (1/VZr) + 3), groupOnX = FALSE, alpha=0.2) + 
  # precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +

  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(size=3, shape=21, fill = "black") +
  annotate('text', x = -1, y = "Overall mean", label=paste("italic(k)==", length(dat$Zr)), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black",hjust = 0.5, angle = 90)) 

#ggsave(plot = fig_ma, filename = "fig_2a.pdf", height = 2, width = 8)
# ggploty 0 does not work (Error in unique.default(x) : unimplemented type 'expression' in 'HashTableSetup')
fig_ma
```

**Figure 2a:** The effect XXXXXX

## Meta-regression

We ran a univaraite meta-regression model for each of following moderators: 1) `symbiosis`, 2) `host_tax_broad`, 3) `symbiont_tax_broad`, 4) `host_range_link_ratio`, 5) `host_range_taxonomic_breadth`, 6) `mode_of_transmission_broad`, and 7) `endo_or_ecto`. The results from these models are presented in the main text. 

In addtion to these, we ran three more univariate models: 1) `host_tax_symbiosis` (equivalent to the interactoin term between `symbiosis` and `host_tax_symbiosis`; `symbiosis*host_tax_symbiosis`), 2) `symbiont_tax_symbiosis` (`symbiosis*symbiont_tax_broad`),  3) `host_symbiont_tax` (`host_tax_symbiosis*symbiont_tax_broad`) and 4) `symbiosis_transmission` (`symbiosis*mode_of_transmission_broad`). There moderators are created below:

```{r}
dat %<>% 
    # host_tax_broad*symbiosis (host_tax_symbiosis) 
  mutate(host_tax_symbiosis = str_c(host_tax_broad, symbiosis), 
         host_tax_symbiosis = ifelse(host_tax_symbiosis == "InvertNA", NA, host_tax_symbiosis),
         host_tax_symbiosis = factor(host_tax_symbiosis),
         # symbiont_tax_broad*symbiosis (symbiont_tax_symbiosis)     
         symbiont_tax_symbiosis = factor(str_c(symbiont_tax_broad, symbiosis)),
         # host_tax_broad*symbiont_tax_broad (host_symbiont_tax)     
         host_symbiont_tax  = factor(str_c(host_tax_broad, symbiont_tax_broad)),
         # symbiosis*mode_of_transmission_broad (symbiosis_transmission)
         symbiosis_transmission  = factor(str_c(symbiosis, mode_of_transmission_broad)),
         # whether p values were the smallest value given the number of randamization - limit_researched (Yes = 1, No = 0)
         limit_rearched = if_else(abs((1/p_value) - no_randomizations) <= 1, 1, 0))

```

### Univaraite (Uni-predictor) analyses

#### The type of symbiosis: parasitism vs. mutualism

```{r}
# meta-regression: mutiple intercepts
mr_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
# meta-regression: contrast
mr_symbiosis2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

**Supplementary Table 2:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiosis`. 
```{r}
# getting marginal R2
r2_symbiosis1 <- R2(mr_symbiosis1)

# getting estimates
res_symbiosis1 <- get_est(mr_symbiosis1, mod = "symbiosis")
res_symbiosis2 <- get_est(mr_symbiosis2, mod = "symbiosis")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiosis1$name), cont_gen(res_symbiosis1$name)),
  Estimate = c(res_symbiosis1$estimate, res_symbiosis2$estimate[2]),
  `Lower CI [0.025]` = c(res_symbiosis1$lowerCL, res_symbiosis2$lowerCL[2]),
  `Upper CI  [0.975]` = c(res_symbiosis1$upperCL, res_symbiosis2$upperCL[2]),
  `V[authors]` = c(mr_symbiosis1$sigma2,  rep(NA, 2)),
  `R2` = c(r2_symbiosis1[1], rep(NA, 2))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```



```{r, fig.width=7, fig.height=2.5}
# adding sample size (k) for each category
k_symbiosis <- dat %>% group_by(symbiosis) %>% count()
# getting estimates and predicitons
pred_symbiosis <- get_pred(mr_symbiosis1, mod = "symbiosis") 
res_symbiosis1 <- left_join(res_symbiosis1, k_symbiosis, by =  c("name" = "symbiosis"))  %>% left_join(pred_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiosis <- ggplot(data = res_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis)), 
                   aes(x= tanh(Zr), y = symbiosis, size = ((1/VZr) + 3), colour = symbiosis), groupOnX = FALSE, alpha=0.2) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  scale_fill_manual(values = c("Mutualist" = "#E69F00", "Parasite" = "#56B4E9")) +
  annotate('text', x = -1, y = res_symbiosis1$name, label= paste("italic(k)==", res_symbiosis1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_symbiosis
```

**Figure 2b:** The effect XXXXXX

#### 


#### The effect of host taxa

```{r}
# reordering
dat$host_tax_broad <- factor(dat$host_tax_broad, levels = c("Microbe", "Plant", "Invert", "Vert"))

#sizes <- factor(sizes, levels = c("small", "medium", "large"))
#sizes
#> [1] small  large  large  small  medium
#> Levels: small medium large
# meta-regression: mutiple intercepts
mr_host_tax_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_host_tax_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_host_tax_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_broad, ref = "Plant"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 3
mr_host_tax_broad4 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_broad, ref = "Invert"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`. 
```{r}
# getting marginal R2
r2_host_tax_broad1 <- R2(mr_host_tax_broad1)

# getting estimates
res_host_tax_broad1 <- get_est(mr_host_tax_broad1, mod = "host_tax_broad")
res_host_tax_broad2 <- get_est(mr_host_tax_broad2, mod = "host_tax_broad")
# the name bit does not work if relevel....
res_host_tax_broad3 <- get_est(mr_host_tax_broad3, mod = "host_tax_broad")
res_host_tax_broad4 <- get_est(mr_host_tax_broad4, mod = "host_tax_broad")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_host_tax_broad1$name), cont_gen(res_host_tax_broad1$name)),
  Estimate = c(res_host_tax_broad1$estimate, res_host_tax_broad2$estimate[-1],  res_host_tax_broad3$estimate[-(1:2)], res_host_tax_broad4$estimate[-(1:3)]),
  `Lower CI [0.025]` = c(res_host_tax_broad1$lowerCL, res_host_tax_broad2$lowerCL[-1], res_host_tax_broad3$lowerCL[-(1:2)], res_host_tax_broad4$lowerCL[-(1:3)]),
  `Upper CI  [0.975]` = c(res_host_tax_broad1$upperCL, res_host_tax_broad2$upperCL[-1], res_host_tax_broad3$upperCL[-(1:2)], res_host_tax_broad4$upperCL[-(1:3)]),
  `V[authors]` = c(mr_host_tax_broad1$sigma2,  rep(NA, 9)),
  `R2` = c(r2_host_tax_broad1[1], rep(NA, 9))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 4}
# adding sample size (k) for each category
k_host_tax_broad <- dat %>% group_by(host_tax_broad) %>% count()
# getting estimates and predicitons
pred_host_tax_broad <- get_pred(mr_host_tax_broad1, mod = "host_tax_broad") 
res_host_tax_broad1 <- left_join(res_host_tax_broad1, k_host_tax_broad, by =  c("name" = "host_tax_broad"))  %>% left_join(pred_host_tax_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_tax_broad <- ggplot(data = res_host_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_tax_broad)), 
                   aes(x= tanh(Zr), y = host_tax_broad, size = ((1/VZr) + 3), colour = host_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = -1, y = res_host_tax_broad1$name, label= paste("italic(k)==", res_host_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_tax_broad
```

**Figure 2c:** The effect XXXXXX

#### The effect of symbiont taxa

```{r}
# reordering
dat$symbiont_tax_broad <- factor(dat$symbiont_tax_broad, levels = c("Microbe", "Plant", "Invert", "Vert"))

#sizes <- factor(sizes, levels = c("small", "medium", "large"))
#sizes
#> [1] small  large  large  small  medium
#> Levels: small medium large
# meta-regression: mutiple intercepts
mr_symbiont_tax_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_symbiont_tax_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_symbiont_tax_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_broad, ref = "Plant"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 3
mr_symbiont_tax_broad4 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_broad, ref = "Invert"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_symbiont_tax_broad1 <- R2(mr_symbiont_tax_broad1)

# getting estimates
res_symbiont_tax_broad1 <- get_est(mr_symbiont_tax_broad1, mod = "symbiont_tax_broad")
res_symbiont_tax_broad2 <- get_est(mr_symbiont_tax_broad2, mod = "symbiont_tax_broad")
res_symbiont_tax_broad3 <- get_est(mr_symbiont_tax_broad3, mod = "symbiont_tax_broad")
res_symbiont_tax_broad4 <- get_est(mr_symbiont_tax_broad4, mod = "symbiont_tax_broad")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiont_tax_broad1$name), cont_gen(res_symbiont_tax_broad1$name)),
  Estimate = c(res_symbiont_tax_broad1$estimate, res_symbiont_tax_broad2$estimate[-1],  res_symbiont_tax_broad3$estimate[-(1:2)], res_symbiont_tax_broad4$estimate[-(1:3)]),
  `Lower CI [0.025]` = c(res_symbiont_tax_broad1$lowerCL, res_symbiont_tax_broad2$lowerCL[-1], res_symbiont_tax_broad3$lowerCL[-(1:2)], res_symbiont_tax_broad4$lowerCL[-(1:3)]),
  `Upper CI  [0.975]` = c(res_symbiont_tax_broad1$upperCL, res_symbiont_tax_broad2$upperCL[-1], res_symbiont_tax_broad3$upperCL[-(1:2)], res_symbiont_tax_broad4$upperCL[-(1:3)]),
  `V[authors]` = c(mr_symbiont_tax_broad1$sigma2,  rep(NA, 9)),
  `R2` = c(r2_symbiont_tax_broad1[1], rep(NA, 9))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 4}
# adding sample size (k) for each category
k_symbiont_tax_broad <- dat %>% group_by(symbiont_tax_broad) %>% count()
# getting estimates and predicitons
pred_symbiont_tax_broad <- get_pred(mr_symbiont_tax_broad1, mod = "symbiont_tax_broad") 
res_symbiont_tax_broad1 <- left_join(res_symbiont_tax_broad1, k_symbiont_tax_broad, by =  c("name" = "symbiont_tax_broad"))  %>% left_join(pred_symbiont_tax_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiont_tax_broad <- ggplot(data = res_symbiont_tax_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiont_tax_broad)), 
                   aes(x= tanh(Zr), y = symbiont_tax_broad, size = ((1/VZr) + 3), colour = symbiont_tax_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00" )) +
  scale_fill_manual(values = c("Microbe" = "#009E73",  "Plant" = "#F0E422",  "Invert"= "#0072B2",  "Vert" = "#D55E00")) +
  scale_y_discrete(labels = c("Microbe" = "Microbe",  "Plant" = "Plant",  "Invert"= "Invertebrate",  "Vert" = "Vertebrate")) +
  annotate('text', x = -1, y = res_symbiont_tax_broad1$name, label= paste("italic(k)==", res_symbiont_tax_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_symbiont_tax_broad
```

**Figure 2d:** The effect XXXXXX

#### Testing specialization 1: host range

```{r}
# meta-regression
mr_host_range_link_ratio <- rma.mv(yi = Zr, V = VZr, mods = ~ log(host_range_link_ratio), random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_host_range_link_ratio <- R2(mr_host_range_link_ratio)

# getting estimates: name does not work for slopes
res_host_range_link_ratio <- get_est(mr_host_range_link_ratio, mod = "log(host_range_link_ratio)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "log(host_range_link_ratio)"),
  Estimate = c(res_host_range_link_ratio$estimate),
  `Lower CI [0.025]` = c(res_host_range_link_ratio$lowerCL),
  `Upper CI  [0.975]` = c(res_host_range_link_ratio$upperCL),
  `V[authors]` = c(mr_host_range_link_ratio$sigma2, NA),
  `R2` = c(r2_host_range_link_ratio[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
# newmods <- seq(-0.3, 2.2, by = 0.1)
# pred_host_range_link_ratio <-predict.rma(mr_host_range_link_ratio, newmods = newmods) 
# ribbon_dat <- tibble(newmods = newmods, ymin = pred_host_range_link_ratio$ci.lb, ymax = pred_host_range_link_ratio$ci.ub)
pred_host_range_link_ratio <-predict.rma(mr_host_range_link_ratio) 

# plotting

fig_host_range_link_ratio <-  dat %>% 
  filter(!is.na(host_range_link_ratio))  %>% # getting ride of NA values
  mutate(ymin = pred_host_range_link_ratio$ci.lb, 
         ymax = pred_host_range_link_ratio$ci.ub,
         ymin2 = pred_host_range_link_ratio$cr.lb,
         ymax2 = pred_host_range_link_ratio$cr.ub,
         pred = pred_host_range_link_ratio$pred) %>% 
  ggplot(aes(x = log(host_range_link_ratio), y = Zr, size = (1/VZr) + 3, )) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(-0.05, 2) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "ln(range link ratio)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(1, 1), legend.justification = c(1, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_range_link_ratio
```


#### Testing specialization 2: taxomic breadth

```{r}
# meta-regression
mr_host_range_taxonomic_breadth <- rma.mv(yi = Zr, V = VZr, mods = ~ log(host_range_taxonomic_breadth), random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_host_range_taxonomic_breadth <- R2(mr_host_range_taxonomic_breadth)

# getting estimates: name does not work for slopes
res_host_range_taxonomic_breadth <- get_est(mr_host_range_link_ratio, mod = "log(host_range_link_ratio)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "log(host_range_taxonomic_breadth)"),
  Estimate = c(res_host_range_taxonomic_breadth$estimate),
  `Lower CI [0.025]` = c(res_host_range_taxonomic_breadth$lowerCL),
  `Upper CI  [0.975]` = c(res_host_range_taxonomic_breadth$upperCL),
  `V[authors]` = c(mr_host_range_taxonomic_breadth$sigma2, NA),
  `R2` = c(r2_host_range_taxonomic_breadth[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_host_range_taxonomic_breadth <-predict.rma(mr_host_range_taxonomic_breadth) 

# plotting

fig_host_range_taxonomic_breadth <-  dat %>% 
  filter(!is.na(host_range_taxonomic_breadth))  %>% # getting ride of NA values
  mutate(ymin = pred_host_range_taxonomic_breadth$ci.lb, 
         ymax = pred_host_range_taxonomic_breadth$ci.ub,
         ymin2 = pred_host_range_taxonomic_breadth$cr.lb,
         ymax2 = pred_host_range_taxonomic_breadth$cr.ub,
         pred = pred_host_range_taxonomic_breadth$pred) %>% 
  ggplot(aes(x = log(host_range_taxonomic_breadth), y = Zr, size = (1/VZr) + 3, )) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0, 1.5) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "ln(range link ratio)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(1, 1), legend.justification = c(1, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_range_taxonomic_breadth
```

```{r}
# reordering
dat$endo_or_ecto <- factor(dat$endo_or_ecto, levels = c("Endo/Ecto", "Endo", "Ecto"))

# meta-regression: mutiple intercepts
mr_endo_or_ecto1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ endo_or_ecto - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_endo_or_ecto2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ endo_or_ecto, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_endo_or_ecto3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(endo_or_ecto, ref = "Endo"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `endo_or_ecto`. 
```{r}
# getting marginal R2
r2_endo_or_ecto1 <- R2(mr_endo_or_ecto1)

# getting estimates
res_endo_or_ecto1 <- get_est(mr_endo_or_ecto1, mod = "endo_or_ecto")
res_endo_or_ecto2 <- get_est(mr_endo_or_ecto2, mod = "endo_or_ecto")
res_endo_or_ecto3 <- get_est(mr_endo_or_ecto3, mod = "endo_or_ecto")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_endo_or_ecto1$name), cont_gen(res_endo_or_ecto1$name)),
  Estimate = c(res_endo_or_ecto1$estimate, res_endo_or_ecto2$estimate[-1],  res_endo_or_ecto3$estimate[-(1:2)]),
  `Lower CI [0.025]` = c(res_endo_or_ecto1$lowerCL, res_endo_or_ecto2$lowerCL[-1], res_endo_or_ecto3$lowerCL[-(1:2)]),
  `Upper CI  [0.975]` = c(res_endo_or_ecto1$upperCL, res_endo_or_ecto2$upperCL[-1], res_endo_or_ecto3$upperCL[-(1:2)]),
  `V[authors]` = c(mr_endo_or_ecto1$sigma2,  rep(NA, 5)),
  `R2` = c(r2_endo_or_ecto1[1], rep(NA, 5))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

```{r, fig.width=7, fig.height= 4}
# adding sample size (k) for each category
k_endo_or_ecto <- dat %>% group_by(endo_or_ecto) %>% count()
# getting estimates and predicitons
pred_endo_or_ecto <- get_pred(mr_endo_or_ecto1, mod = "endo_or_ecto") 
res_endo_or_ecto1 <- left_join(res_endo_or_ecto1, k_endo_or_ecto, by =  c("name" = "endo_or_ecto"))  %>% left_join(pred_endo_or_ecto)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_endo_or_ecto <- ggplot(data = res_endo_or_ecto1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(endo_or_ecto)), 
                   aes(x= tanh(Zr), y = endo_or_ecto, size = ((1/VZr) + 3), colour = endo_or_ecto), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_fill_manual(values = c("Endo/Ecto" = "#0072B2",  "Endo" = "#D55E00",  "Ecto"= "#CC79A7")) +
  scale_y_discrete(labels = c("Endo/Ecto" = "Both",  "Endo" = "Endosymbiosis",  "Ecto"= "Ectosymbiosis")) +
  annotate('text', x = -1, y = res_endo_or_ecto1$name, label= paste("italic(k)==", res_endo_or_ecto1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction = "horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_endo_or_ecto
```

**Figure 2g:** The effect XXXXXX


#### The effect of the model of transmission

```{r}
# meta-regression: mutiple intercepts
mr_mode_of_transmission_broad1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ mode_of_transmission_broad - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 1
mr_mode_of_transmission_broad2 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ mode_of_transmission_broad, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# meta-regression: contrast 2
mr_mode_of_transmission_broad3 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(mode_of_transmission_broad, ref = "vertical"), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `mode_of_transmission_broad`. 
```{r}
# getting marginal R2
r2_mode_of_transmission_broad1 <- R2(mr_mode_of_transmission_broad1)

# getting estimates
res_mode_of_transmission_broad1 <- get_est(mr_mode_of_transmission_broad1, mod = "mode_of_transmission_broad")
res_mode_of_transmission_broad2 <- get_est(mr_mode_of_transmission_broad2, mod = "mode_of_transmission_broad")
res_mode_of_transmission_broad3 <- get_est(mr_mode_of_transmission_broad3, mod = "mode_of_transmission_broad")

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_mode_of_transmission_broad1$name), cont_gen(res_mode_of_transmission_broad1$name)),
  Estimate = c(res_mode_of_transmission_broad1$estimate, res_mode_of_transmission_broad2$estimate[-1],  res_mode_of_transmission_broad3$estimate[-(1:2)]),
  `Lower CI [0.025]` = c(res_mode_of_transmission_broad1$lowerCL, res_mode_of_transmission_broad2$lowerCL[-1], res_mode_of_transmission_broad3$lowerCL[-(1:2)]),
  `Upper CI  [0.975]` = c(res_mode_of_transmission_broad1$upperCL, res_mode_of_transmission_broad2$upperCL[-1], res_mode_of_transmission_broad3$upperCL[-(1:2)]),
  `V[authors]` = c(mr_mode_of_transmission_broad1$sigma2,  rep(NA, 5)),
  `R2` = c(r2_mode_of_transmission_broad1[1], rep(NA, 5))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left") 
```

```{r, fig.width=7, fig.height= 3.5}
# adding sample size (k) for each category
k_mode_of_transmission_broad <- dat %>% group_by(mode_of_transmission_broad) %>% count()
# getting estimates and predicitons
pred_mode_of_transmission_broad <- get_pred(mr_mode_of_transmission_broad1, mod = "mode_of_transmission_broad") 
res_mode_of_transmission_broad1 <- left_join(res_mode_of_transmission_broad1, k_mode_of_transmission_broad, by =  c("name" = "mode_of_transmission_broad"))  %>% left_join(pred_mode_of_transmission_broad)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_mode_of_transmission_broad <- ggplot(data = res_mode_of_transmission_broad1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(mode_of_transmission_broad)), 
                   aes(x= tanh(Zr), y = mode_of_transmission_broad, size = ((1/VZr) + 3), colour = mode_of_transmission_broad), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_fill_manual(values = c("both" = "#0072B2",  "horizontal" = "#D55E00",  "vertical"= "#CC79A7")) +
  scale_y_discrete(labels = c("both" = "Both",  "horizontal" = "Horizontal",  "vertical"= "Vertical")) +
  annotate('text', x = -1, y = res_mode_of_transmission_broad1$name, label= paste("italic(k)==", res_mode_of_transmission_broad1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction = "horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_mode_of_transmission_broad
```

**Figure 2g:** The effect XXXXXX


#### The combined effect of symbiosis and mode of transmission

```{r}
# reordering
dat$symbiosis_transmission <- factor(dat$symbiosis_transmission,
                                 levels = c("Mutualistboth", "Mutualisthorizontal","Mutualistvertical", "Parasiteboth", "Parasitehorizontal"),
                                labels = c("MutualistBoth", "MutualistHorizontal","MutualistVertical", "ParasiteBoth", "ParasiteHorizontal"))

# meta-regression: mutiple intercepts
mr_symbiosis_transmission1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis_transmission - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$symbiosis_transmission)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiosis_transmission, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_symbiosis_transmission <- map(level_names[-length(level_names)], run_rma)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`. 
```{r}
# getting marginal R2
r2_symbiosis_transmission1 <- R2(mr_symbiosis_transmission1)

# getting estimates
res_symbiosis_transmission1 <- get_est(mr_symbiosis_transmission1, mod = "symbiosis_transmission")
res_symbiosis_transmission <- map(mr_symbiosis_transmission, ~ get_est(.x, mod = "symbiosis_transmission"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:4)

# you need to flatten twice: first to make it a list and make it a vector
estiamtes <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_symbiosis_transmission, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiosis_transmission1$name), cont_gen(res_symbiosis_transmission1$name)),
  Estimate = c(res_symbiosis_transmission1$estimate, estiamtes),
  `Lower CI [0.025]` = c(res_symbiosis_transmission1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_symbiosis_transmission1$upperCL,lowerCLs),
  `V[authors]` = c(mr_symbiosis_transmission1$sigma2,  rep(NA, (5 + choose(5,2))- 1)),
  `R2` = c(r2_symbiosis_transmission1[1], rep(NA, (5 + choose(5, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 5}
# colour list
colour_ls <- c("#000000", "#E69F00", "#56B4E9", "#009E73",  "#F0E422",  "#0072B2",  "#D55E00", "#CC79A7", "#00008B", "#8B0A50", "#54FF9F", "#999999")

# adding sample size (k) for each category
k_symbiosis_transmission <- dat %>% group_by(symbiosis_transmission) %>% count()
# getting estimates and predicitons
pred_symbiosis_transmission <- get_pred(mr_symbiosis_transmission1, mod = "symbiosis_transmission") 
res_symbiosis_transmission1 <- left_join(res_symbiosis_transmission1, k_symbiosis_transmission, by =  c("name" = "symbiosis_transmission"))  %>% left_join(pred_symbiosis_transmission)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiosis_transmission <- ggplot(data = res_symbiosis_transmission1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiosis_transmission)), 
                   aes(x= tanh(Zr), y = symbiosis_transmission, size = ((1/VZr) + 3), colour = symbiosis_transmission), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =   c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_fill_manual(values = c("MutualistBoth"= colour_ls[1], "MutualistHorizontal"= colour_ls[2], "MutualistVertical" = colour_ls[3],"ParasiteBoth"= colour_ls[4], "ParasiteHorizontal" = colour_ls[5])) +
  scale_y_discrete(labels = c("MutualistBoth" = "Mutualist-\nBoth", "MutualistHorizontal" = "Mutualist-\nHorizontal","MutualistVertical" = "Mutualist-\nVertical", "ParasiteBoth" = "Parasite-\nBoth", "ParasiteHorizontal" = "Parasite-\nHorizontal")) +
  annotate('text', x = -1, y = res_symbiosis_transmission1$name, label= paste("italic(k)==", res_symbiosis_transmission1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_symbiosis_transmission
```

NOTE!!!
* Do the REF REF REF 
* Justification of the use of combined datasets.... - done
* just do the main one for all three datasets but not others
* or we could - provide forest plots of all the three datasets???? (do it later)
* heterogeneity - done 





* one-by-one analyses here...

#### The combined effect of host taxa and symbiosis (parasitism vs. mutualism)

```{r}
# reordering
dat$host_tax_symbiosis <- factor(dat$host_tax_symbiosis, 
                                 levels = c("MicrobeMutualist", "MicrobeParasite",  "PlantMutualist", "PlantParasite", "InvertMutualist",  "InvertParasite",  "VertMutualist", "VertParasite"))

# meta-regression: mutiple intercepts
mr_host_tax_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_tax_symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$host_tax_symbiosis)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_tax_symbiosis, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_host_tax_symbiosis <- map(level_names[-length(level_names)], run_rma)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`. 
```{r}
# getting marginal R2
r2_host_tax_symbiosis1 <- R2(mr_host_tax_symbiosis1)

# getting estimates
res_host_tax_symbiosis1 <- get_est(mr_host_tax_symbiosis1, mod = "host_tax_symbiosis")
res_host_tax_symbiosis <- map(mr_host_tax_symbiosis, ~ get_est(.x, mod = "host_tax_symbiosis"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:7)

# you need to flatten twice: first to make it a list and make it a vector
estiamtes <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_host_tax_symbiosis, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_host_tax_symbiosis1$name), cont_gen(res_host_tax_symbiosis1$name)),
  Estimate = c(res_host_tax_symbiosis1$estimate, estiamtes),
  `Lower CI [0.025]` = c(res_host_tax_symbiosis1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_host_tax_symbiosis1$upperCL,lowerCLs),
  `V[authors]` = c(mr_host_tax_symbiosis1$sigma2,  rep(NA, (8 + choose(8,2))- 1)),
  `R2` = c(r2_host_tax_symbiosis1[1], rep(NA, (8 + choose(8, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 8}
# adding sample size (k) for each category
k_host_tax_symbiosis <- dat %>% group_by(host_tax_symbiosis) %>% count()
# getting estimates and predicitons
pred_host_tax_symbiosis <- get_pred(mr_host_tax_symbiosis1, mod = "host_tax_symbiosis") 
res_host_tax_symbiosis1 <- left_join(res_host_tax_symbiosis1, k_host_tax_symbiosis, by =  c("name" = "host_tax_symbiosis"))  %>% left_join(pred_host_tax_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_tax_symbiosis <- ggplot(data = res_host_tax_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_tax_symbiosis)), 
                   aes(x= tanh(Zr), y = host_tax_symbiosis, size = ((1/VZr) + 3), colour = host_tax_symbiosis), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =   c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertMutualist"= colour_ls[7],     "VertParasite"= colour_ls[8] )) +
  scale_fill_manual(values = c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertMutualist"= colour_ls[7],     "VertParasite"= colour_ls[8] )) +
  scale_y_discrete(labels = c("MicrobeMutualist"= "Microbe-\nMutualist", "MicrobeParasite"= "Microbe-\nParasite",  "PlantMutualist" = "Plant-\nMutualist", "PlantParasite"="Plant-\nParasite", "InvertMutualist" = "Invertebrate-\nMutualist",   "InvertParasite"= "Invertebrate-\nParasite", "VertMutualist"= "Vertebrate-\nMutualist",  "VertParasite"= "Vertebrate-\nParasite" )) +
  annotate('text', x = -1, y = res_host_tax_symbiosis1$name, label= paste("italic(k)==", res_host_tax_symbiosis1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_tax_symbiosis
```

#### The combined effect of symbiont taxa and symbiosis (parasitism vs. mutualism)

NOTE - symbiont_tax_symbiosis = 21 combinations

```{r}
# reordering
dat$symbiont_tax_symbiosis <- factor(dat$symbiont_tax_symbiosis, 
                                     levels = c(  "MicrobeMutualist", "MicrobeParasite",  "PlantMutualist", "PlantParasite","InvertMutualist", "InvertParasite", "VertParasite"))

# meta-regression: multiple intercepts
mr_symbiont_tax_symbiosis1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiont_tax_symbiosis - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$symbiont_tax_symbiosis)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(symbiont_tax_symbiosis, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_symbiont_tax_symbiosis <- map(level_names[-length(level_names)], run_rma)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`. 
```{r}
# getting marginal R2
r2_symbiont_tax_symbiosis1 <- R2(mr_symbiont_tax_symbiosis1)

# getting estimates
res_symbiont_tax_symbiosis1 <- get_est(mr_symbiont_tax_symbiosis1, mod = "symbiont_tax_symbiosis")
res_symbiont_tax_symbiosis <- map(mr_symbiont_tax_symbiosis, ~ get_est(.x, mod = "symbiont_tax_symbiosis"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:6)

# you need to flatten twice: first to make it a list and make it a vector
estiamtes <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()
lowerCLs <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()
upperCLs <- map2(res_symbiont_tax_symbiosis, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_symbiont_tax_symbiosis1$name), cont_gen(res_symbiont_tax_symbiosis1$name)),
  Estimate = c(res_symbiont_tax_symbiosis1$estimate, estiamtes),
  `Lower CI [0.025]` = c(res_symbiont_tax_symbiosis1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_symbiont_tax_symbiosis1$upperCL,lowerCLs),
  `V[authors]` = c(mr_symbiont_tax_symbiosis1$sigma2,  rep(NA, (7 + choose(7,2))- 1)),
  `R2` = c(r2_symbiont_tax_symbiosis1[1], rep(NA, (7 + choose(7, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 7}
# adding sample size (k) for each category
k_symbiont_tax_symbiosis <- dat %>% group_by(symbiont_tax_symbiosis) %>% count()
# getting estimates and predicitons
pred_symbiont_tax_symbiosis <- get_pred(mr_symbiont_tax_symbiosis1, mod = "symbiont_tax_symbiosis") 
res_symbiont_tax_symbiosis1 <- left_join(res_symbiont_tax_symbiosis1, k_symbiont_tax_symbiosis, by =  c("name" = "symbiont_tax_symbiosis"))  %>% left_join(pred_symbiont_tax_symbiosis)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_symbiont_tax_symbiosis <- ggplot(data = res_symbiont_tax_symbiosis1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(symbiont_tax_symbiosis)), 
                   aes(x= tanh(Zr), y = symbiont_tax_symbiosis, size = ((1/VZr) + 3), colour = symbiont_tax_symbiosis), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  # setting colours
  scale_color_manual(values =   c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertParasite"= colour_ls[8] )) +
  scale_fill_manual(values = c("MicrobeMutualist"= colour_ls[1], "MicrobeParasite"= colour_ls[2],  "PlantMutualist"= colour_ls[3], "PlantParasite"= colour_ls[4], "InvertMutualist" = colour_ls[5],  "InvertParasite"= colour_ls[6], "VertParasite"= colour_ls[8] )) +
  scale_y_discrete(labels = c("MicrobeMutualist"= "Microbe-\nMutualist", "MicrobeParasite"= "Microbe-\nParasite",  "PlantMutualist" = "Plant-\nMutualist", "PlantParasite"="Plant-\nParasite", "InvertMutualist" = "Invertebrate-\nMutualist",   "InvertParasite"= "Invertebrate-\nParasite",  "VertParasite"= "Vertebrate-\nParasite" )) +
  annotate('text', x = -1, y = res_symbiont_tax_symbiosis1$name, label= paste("italic(k)==", res_symbiont_tax_symbiosis1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_symbiont_tax_symbiosis
```


#### The combined effect of host and symbiont taxa

NOTE -- host_symbiont_tax - 11 varaibles and 55 combinations!!!!

```{r}
# reordering
dat$host_symbiont_tax <- factor(dat$host_symbiont_tax, 
                                     levels = c("MicrobeInvert", "MicrobeMicrobe", "MicrobePlant","PlantInvert", "PlantMicrobe", "InvertInvert", "InvertMicrobe", "InvertPlant", "VertInvert", "VertMicrobe", "VertVert"))

# meta-regression: multiple intercepts
mr_host_symbiont_tax1 <- rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ host_symbiont_tax - 1, 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)

# # meta-regression: contrasts x 10
# getting the level names out
level_names <- levels(dat$host_symbiont_tax)

# helper function to run metafor meta-regression
run_rma <- function(name) {
  rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ relevel(host_symbiont_tax, ref = name), 
                       test = "t",
                       random = ~ 1 | authors, 
                       data = dat)
}

# results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
mr_host_symbiont_tax <- map(level_names[-length(level_names)], run_rma)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `host_tax_broad`. 
```{r}
# getting marginal R2
r2_host_symbiont_tax1 <- R2(mr_host_symbiont_tax1)

# getting estimates
res_host_symbiont_tax1 <- get_est(mr_host_symbiont_tax1, mod = "host_symbiont_tax")
res_host_symbiont_tax <- map(mr_host_symbiont_tax, ~ get_est(.x, mod = "host_symbiont_tax"))

# a list of the numbers to take out unnecessary contrasts
contra_list <- Map(seq, from=1, to=1:10)

# you need to flatten twice: first to make it a list and make it a vector
estiamtes <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"estimate"]) %>% flatten() %>% flatten_dbl()

lowerCLs <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"lowerCL"]) %>% flatten() %>% flatten_dbl()

upperCLs <- map2(res_host_symbiont_tax, contra_list, ~.x[-(.y),"upperCL"]) %>% flatten() %>% flatten_dbl()

# creating a table
tibble(
  `Fixed effect` = c(as.character(res_host_symbiont_tax1$name), cont_gen(res_host_symbiont_tax1$name)),
  Estimate = c(res_host_symbiont_tax1$estimate, estiamtes),
  `Lower CI [0.025]` = c(res_host_symbiont_tax1$lowerCL,lowerCLs),
  `Upper CI  [0.975]` = c(res_host_symbiont_tax1$upperCL,lowerCLs),
  `V[authors]` = c(mr_host_tax_symbiosis1$sigma2,  rep(NA, (11 + choose(11,2))- 1)),
  `R2` = c(r2_host_symbiont_tax1[1], rep(NA, (11 + choose(11, 2))- 1))) %>% kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "300px")
```

```{r, fig.width=7, fig.height= 10}
# colour list
#colour_ls <- c("#000000", "#E69F00", "#56B4E9", "#009E73",  "#F0E422",  "#0072B2",  "#D55E00", "#CC79A7", "#00008B", "#8B0A50", "#54FF9F", "#999999")

# adding sample size (k) for each category
k_host_symbiont_tax <- dat %>% group_by(host_symbiont_tax) %>% count()
# getting estimates and predicitons
pred_host_symbiont_tax <- get_pred(mr_host_symbiont_tax1, mod = "host_symbiont_tax") 
res_host_symbiont_tax1 <- left_join(res_host_symbiont_tax1, k_host_symbiont_tax, by =  c("name" = "host_symbiont_tax"))  %>% left_join(pred_host_symbiont_tax)
#res_symbiosis1 
# drawing a funnel plot - fig 2b
fig_host_symbiont_tax <- ggplot(data = res_host_symbiont_tax1, aes(x = tanh(estimate), y = name)) +
  scale_x_continuous(limits=c(-1, 1), breaks = seq(-1, 1, by = 0.2) ) +
  geom_quasirandom(data = dat %>% filter(!is.na(host_symbiont_tax)), 
                   aes(x= tanh(Zr), y = host_symbiont_tax, size = ((1/VZr) + 3), colour = host_symbiont_tax), groupOnX = FALSE, alpha=0.4) + 
  # 95 %precition interval (PI)
  geom_errorbarh(aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),  height = 0, show.legend = F, size = 0.5, alpha = 0.6) +
  # 95 %CI
  geom_errorbarh(aes(xmin = tanh(lowerCL), xmax = tanh(upperCL)),  height = 0, show.legend = F, size = 1.2) +
  geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
  # creating dots and different size (bee-swarm and bubbles)
  geom_point(aes(fill = name), size = 3, shape = 21) + #
  # setting colours
  scale_color_manual(values =  c("MicrobeInvert" = colour_ls[1],  "MicrobeMicrobe"= colour_ls[2], "MicrobePlant" = colour_ls[3], "PlantInvert" = colour_ls[4],"PlantMicrobe" = colour_ls[5], "InvertInvert"  = colour_ls[6],  "InvertMicrobe" = colour_ls[7], "InvertPlant" = colour_ls[8],"VertInvert"  = colour_ls[9], "VertMicrobe"= colour_ls[10],"VertVert"  = colour_ls[11])) +
  scale_fill_manual(values = c("MicrobeInvert" = colour_ls[1],  "MicrobeMicrobe"= colour_ls[2], "MicrobePlant" = colour_ls[3], "PlantInvert" = colour_ls[4],"PlantMicrobe" = colour_ls[5], "InvertInvert"  = colour_ls[6],  "InvertMicrobe" = colour_ls[7], "InvertPlant" = colour_ls[8],"VertInvert"  = colour_ls[9], "VertMicrobe"= colour_ls[10],"VertVert"  = colour_ls[11])) +
  scale_y_discrete(labels = c("MicrobeInvert" = "Microbe-\nInvertebrate",  "MicrobeMicrobe"= "Microbe-\nMicrobe", "MicrobePlant" = "Microbe-\nPlant", "PlantInvert" = "Plant-\nInvertebrate","PlantMicrobe" = "Plant-\nMicrobe", "InvertInvert"  = "Invertebrate\nInvertebrate",  "InvertMicrobe" = "Invertebrate-\nMicrobe", "InvertPlant" = "Invertebrate-\nPlant","VertInvert"  = "Vertebrate-\nInvertebrate", "VertMicrobe"= "Vertebrate-\nMicrobe", "VertVert"  = "Vertebrate-\nVertebrate")) +
  annotate('text', x = -1, y = res_host_symbiont_tax1$name, label= paste("italic(k)==", res_host_symbiont_tax1$n), parse=TRUE, hjust = "left", size=3.5) +
  labs(x = expression(paste(italic(r), " (correlaton)")), y = "", size = expression(paste(italic(n), " (# of species)")) ) +
  guides(fill = "none", colour = "none") +
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0,1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fig_host_symbiont_tax
```

### Addtional analyses

### Model selection (Mulit-predictor model)

```{r}
# creates a new function to run in MuMIn
updated.rma.mv <- updateable(rma.mv)
updated.rma.mv

# testing the new function 
# use method = "ML" so that we can compare AIC
mr_full <- updated.rma.mv(yi = Zr, 
                       V = VZr, 
                       mods = ~ symbiosis + 
                         host_tax_broad +
                         symbiont_tax_broad +
                         mode_of_transmission_broad +
                         endo_or_ecto +
                         log(host_range_link_ratio),
                       test = "t",
                       random = ~ 1 | authors,
                       method="ML",
                       data = dat)

# summary(mr_full)
# 
# # testing call of new function
# getCall(mr_full)
# 
# # update the new function to run in MuMIn
# update(mr_full)

#=============================
### additional methods for "rma.mv" class (made by Kamil Barton)
### we need this to run model selection with rma.mv in MuMIn
#=============================
formula.rma.mv <- function (x, ...) return(eval(getCall(x)$mods))

makeArgs.rma.mv <-
  function (obj, termNames, comb, opt, ...) {
    ret <- MuMIn:::makeArgs.default(obj, termNames, comb, opt)
    names(ret)[1L] <- "mods"
    ret
  }

nobs.rma.mv <-
  function (object, ...)
    attr(logLik(object), "nall")

coefTable.rma.mv <- function (model, ...)
  MuMIn:::.makeCoefTable(model$b, model$se, coefNames = rownames(model$b))
#=============================

# testing dredge
#dredge(full.model, evaluate=F) # show all candidate models
# n = 32 model exisits
candidates <- dredge(mr_full)

# displays delta AICc <2
candidates_aic2 <- subset(candidates, delta < 2)

# model averaging
# it seems like models are using z values rather than t values (which will be OK)
mr_averaged_aic2 <- summary(model.avg(candidates,  delta < 2))

# relative importance of each predictor
importance <- importance(candidates)

# use REML if not for model comparision
model1 <- rma.mv(yi = Zr, V = VZr, mods = ~  mode_of_transmission_broad + host_tax_broad, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)
model2 <- rma.mv(yi = Zr, V = VZr, mods = ~  mode_of_transmission_broad + host_tax_broad + symbiosis, test = "t",
                 random = ~ 1 | authors, method="REML", data = dat)

```

** table model aic etc
```{r}
# creating a table
tibble(
  `Model (variable weight)` = c("Model1", "Model2", "(Sum of weights)"),
  transmission = c(as.character(candidates_aic2$mode_of_transmission_broad),round(importance[1],3) ),
  host_tax = c(as.character(candidates_aic2$host_tax_broad),round(importance[2], 3)),
  symbiosis =  c(as.character(candidates_aic2$symbiosis),round(importance[3], 3)),
  symbiont_tax = c(as.character(candidates_aic2$symbiont_tax_broad),round(importance[4], 3)),
  endo_or_ecto = c(as.character(candidates_aic2$endo_or_ecto),round(importance[5], 3)),
  `host_range` = c(as.character(candidates_aic2$`log(host_range_link_ratio)`),round(importance[6], 3)),
  delta_AICc = c(candidates_aic2$delta, NA),
  Weight = c(candidates_aic2$weight, NA)) %>% 
  kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

** model averaged estiamtes (full average)
```{r}

# getting averaged R2 and variance components not provided by the MuMIn package
average_sigma2 <- weighted.mean(x = c(model1$sigma2, model2$sigma2), w = candidates_aic2$weight)
average_R2 <- weighted.mean(x = c(R2(model1)[1], R2(model2)[1])  ,w = candidates_aic2$weight)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutulist)",
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", 
                     "both-horizontal", "both-vertical", "Mutulist-Parasite"),
  Estimate = mr_averaged_aic2$coefmat.full[,1],
  `Lower CI [0.025]` =  mr_averaged_aic2$coefmat.full[,1] - mr_averaged_aic2$coefmat.full[,2]*qnorm(0.975),
  `Upper CI  [0.975]` =  mr_averaged_aic2$coefmat.full[,1] + mr_averaged_aic2$coefmat.full[,2]*qnorm(0.975),
  `V[authors]` = c(average_sigma2, rep(NA,6)),
  `R2` = c(average_R2, rep(NA,6))) %>% 
  kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

## Publication Bias and Sensitivity Analysis

* boundary problems
 ** no of randomzations and limit_rearched
* Time lag bias

### Residual funnel plot

```{r}
# 
res_funnel_plot <- rma.mv(yi = Zr, V = VZr, 
                               mods = ~ mode_of_transmission_broad +
                                 host_tax_broad +
                                 symbiosis, 
                               random = ~ 1 | authors, data = dat)

funnel(res_funnel_plot, yaxis = "seinv")
```


### Univaraite Egger regression

```{r}
# 
egger_regression_uni <- rma.mv(yi = Zr, V = VZr, mods = ~ sqrt(VZr), random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_egger_regression_uni <- R2(egger_regression_uni)

# getting estimates: name does not work for slopes
res_egger_regression_uni <- get_est(egger_regression_uni, mod = "sqrt(VZr)")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "sqrt(VZr)"),
  Estimate = c(res_egger_regression_uni$estimate),
  `Lower CI [0.025]` = c(res_egger_regression_uni$lowerCL),
  `Upper CI  [0.975]` = c(res_egger_regression_uni$upperCL),
  `V[authors]` = c(egger_regression_uni$sigma2, NA),
  `R2` = c(r2_egger_regression_uni[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_egger_regression_uni <-predict.rma(egger_regression_uni) 

# plotting

fit_egger_regression_uni <-  dat %>% 
  mutate(ymin = pred_egger_regression_uni$ci.lb, 
         ymax = pred_egger_regression_uni$ci.ub,
         ymin2 = pred_egger_regression_uni$cr.lb,
         ymax2 = pred_egger_regression_uni$cr.ub,
         pred = pred_egger_regression_uni$pred) %>% 
  ggplot(aes(x = sqrt(VZr), y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0.05, 0.45) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "sqrt(sampling variance)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_egger_regression_uni
```

### Multivaraite Egger regression

```{r}
# 
egger_regression_mul <- rma.mv(yi = Zr, V = VZr, 
                               mods = ~ sqrt(VZr) +
                                 mode_of_transmission_broad +
                                 host_tax_broad +
                                 symbiosis, 
                               random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_egger_regression_mul <- R2(egger_regression_mul)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutulist)", "sqrt(VZr)", "both-horizontal", "both-vertical", 
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", "Mutulist-Parasite"),
  Estimate = c(egger_regression_mul$b),
  `Lower CI [0.025]` = c(egger_regression_mul$ci.lb),
  `Upper CI  [0.975]` = c(egger_regression_mul$ci.ub),
  `V[authors]` = c(egger_regression_mul$sigma2, rep(NA,7)),
  `R2` = c(r2_egger_regression_mul[1], rep(NA,7))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_egger_regression_mul <-predict.rma(egger_regression_mul) 

# plotting

fit_egger_regression_mul <-  dat %>% 
  filter(!is.na(mode_of_transmission_broad) & !is.na(host_tax_broad) & !is.na(symbiosis))  %>% # getting ride of NA values
  mutate(ymin = pred_egger_regression_mul$ci.lb, 
         ymax = pred_egger_regression_mul$ci.ub,
         ymin2 = pred_egger_regression_mul$cr.lb,
         ymax2 = pred_egger_regression_mul$cr.ub,
         pred = pred_egger_regression_mul$pred) %>% 
  ggplot(aes(x = sqrt(VZr), y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(0.05, 0.45) +
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "sqrt(sampling variance)", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_egger_regression_mul
```

### Univaraite time-lag bias
```{r}
# 
time_lag_effect_uni <- rma.mv(yi = Zr, V = VZr, mods = ~ year, random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_time_lag_effect_uni <- R2(time_lag_effect_uni)

# getting estimates: name does not work for slopes
res_time_lag_effect_uni <- get_est(time_lag_effect_uni, mod = "year")

# creating a table
tibble(
  `Fixed effect` = c("Intercept", "Year"),
  Estimate = c(res_time_lag_effect_uni$estimate),
  `Lower CI [0.025]` = c(res_time_lag_effect_uni$lowerCL),
  `Upper CI  [0.975]` = c(res_time_lag_effect_uni$upperCL),
  `V[authors]` = c(time_lag_effect_uni$sigma2, NA),
  `R2` = c(r2_time_lag_effect_uni[1], NA)) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_time_lag_effect_uni <-predict.rma(time_lag_effect_uni) 

# plotting

fit_time_lag_effect <-  dat %>% 
  mutate(ymin = pred_time_lag_effect_uni$ci.lb, 
         ymax = pred_time_lag_effect_uni$ci.ub,
         ymin2 = pred_time_lag_effect_uni$cr.lb,
         ymax2 = pred_time_lag_effect_uni$cr.ub,
         pred = pred_time_lag_effect_uni$pred) %>% 
  ggplot(aes(x = year, y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(1994,2019) +
  scale_x_continuous(breaks = c(1995, 2000, 2005, 2010, 2015, 2020)) + 
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "Year", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_time_lag_effect
```

### Multivaraite time-lag bias
```{r}
# 
time_lag_effect_mul <- rma.mv(yi = Zr, V = VZr, 
                              mods = ~ year +
                                mode_of_transmission_broad +
                                host_tax_broad +
                                symbiosis,
                              random = ~ 1 | authors, data = dat)

```

**Supplementary Table 3:**
Regression coefficients (Estimate), 95% confidence intervals (CIs), variance components (V) and variance examplained, *R*^2^~[marginal]~ (R2) from the meta-regression with `symbiont_tax_broad`. 
```{r}
# getting marginal R2
r2_time_lag_effect_mul <- R2(time_lag_effect_mul)

# creating a table
tibble(
  `Fixed effect` = c("Intercept (both-Microbe-Mutulist)", "Year", "both-horizontal", "both-vertical", 
                     "Microbe-Plant", "Microbe-Invert", "Microbe-Vert", "Mutulist-Parasite"),
  Estimate = c(time_lag_effect_mul$b),
  `Lower CI [0.025]` = c(time_lag_effect_mul$ci.lb),
  `Upper CI  [0.975]` = c(time_lag_effect_mul$ci.ub),
  `V[authors]` = c(time_lag_effect_mul$sigma2, rep(NA,7)),
  `R2` = c(r2_time_lag_effect_mul[1], rep(NA,7))) %>% kable("html", digits = 3) %>%
  kable_styling("striped", position = "left")
```

```{r, fig.width=7, fig.height= 4}
pred_time_lag_effect_mul <-predict.rma(time_lag_effect_mul) 

# plotting
fit_time_lag_effect_mul <-  dat %>% 
  filter(!is.na(mode_of_transmission_broad) & !is.na(host_tax_broad) & !is.na(symbiosis))  %>% 
  mutate(ymin = pred_time_lag_effect_mul$ci.lb, 
         ymax = pred_time_lag_effect_mul$ci.ub,
         ymin2 = pred_time_lag_effect_mul$cr.lb,
         ymax2 = pred_time_lag_effect_mul$cr.ub,
         pred = pred_time_lag_effect_mul$pred) %>% 
  ggplot(aes(x = year, y = Zr, size = (1/VZr) + 3)) +
  geom_point(shape = 21, fill = "grey90") +
  #geom_ribbon(aes(ymin = ymin, ymax = ymax), fill = "#0072B2")  + # not quite sure why this does not work
  geom_smooth(aes(y = ymin2), method =  "loess", se = FALSE, lty =  "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymax2), method =  "loess", se = FALSE, lty = "dotted", lwd = 0.25, colour = "#0072B2") +
  geom_smooth(aes(y = ymin), method =  "loess", se = FALSE,lty = "dotted", lwd = 0.25, colour ="#D55E00") +
  geom_smooth(aes(y = ymax), method =  "loess", se = FALSE, lty ="dotted", lwd = 0.25, colour ="#D55E00") + 
  geom_smooth(aes(y = pred), method =  "loess", se = FALSE, lty ="dashed", lwd = 0.5, colour ="black") +  
  ylim(-1, 2) + xlim(1994,2019) +
  scale_x_continuous(breaks = c(1995, 2000, 2005, 2010, 2015, 2020)) + 
  #geom_abline(intercept = mr_host_range_link_ratio$beta[[1]], slope = mr_host_range_link_ratio$beta[[2]], alpha = 0.7, linetype = "dashed", size = 0.5) +
  labs(x = "Year", y = expression(paste(italic(Zr), " (effect size)")), size = expression(paste(italic(n), " (# of species)"))) +
  guides(fill = "none", colour = "none") +
  # themses
  theme_bw() +
  theme(legend.position= c(0, 1), legend.justification = c(0, 1)) +
  theme(legend.direction="horizontal") +
  #theme(legend.background = element_rect(fill = "white", colour = "black")) +
  theme(legend.background = element_blank()) +
  theme(axis.text.y = element_text(size = 10, colour ="black", hjust = 0.5, angle = 90)) 

fit_time_lag_effect_mul
```



### Sensitivity test 1: the number of randamizations

* boundary problems
 ** no of randomzations and limit_rearched = if they are different, then, it could lead to bias
 ** limit_reached = if high - more likley to be underestiamted 

```{r}
# 233 --- Yes = 74 (0.3175966%); No = 159

# symbiosis
sa_random_symbiosis<-lmer(log(no_randomizations) ~ symbiosis + (1 | authors), data = dat)
summary(sa_random_symbiosis)
tidy(sa_random_symbiosis)
r2(sa_random_symbiosis)

sa_random_symbiosis1<-lmer(log(no_randomizations) ~ symbiosis - 1 + (1 | authors), data = dat)
summary(sa_random_symbiosis1)




# host_tax_broad
sa_random_host_tax_broad<-glmer(log(no_randomizations) ~ host_tax_broad + (1 | authors), data = dat)
summary(sa_random_host_tax_broad)

sa_random_host_tax_broad1<-glmer(log(no_randomizations) ~ host_tax_broad - 1 + (1 | authors), data = dat)
summary(sa_random_host_tax_broad1)

sa_limit_host_tax_broad<-glmer(limit_rearched ~ host_tax_broad  + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_host_tax_broad)
r2(sa_limit_host_tax_broad)

sa_limit_host_tax_broad1<-glmer(limit_rearched ~ host_tax_broad - 1  + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_host_tax_broad1)


# mode_of_transmission_broad
sa_random_mode_of_transmission_broad<-glmer(log(no_randomizations) ~ mode_of_transmission_broad + (1 | authors), data = dat)
summary(sa_random_mode_of_transmission_broad)

sa_random_mode_of_transmission_broad1<-glmer(log(no_randomizations) ~ mode_of_transmission_broad - 1 + (1 | authors), data = dat)
summary(sa_random_mode_of_transmission_broad1)

sa_limit_mode_of_transmission_broad<-glmer(limit_rearched ~ mode_of_transmission_broad + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_mode_of_transmission_broad)

sa_limit_mode_of_transmission_broad1<-glmer(limit_rearched ~ mode_of_transmission_broad - 1 + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_mode_of_transmission_broad1)

```

### Sensitivity test 2: reaching the limits

```{r}
# 233 --- Yes = 74 (0.3175966%); No = 159

library(lme4)
install.packages("broom.mixed")
library(broom.mixed)
install.packages("performance")
library(performance)

# symbiosis
## 
sa_random_symbiosis<-lmer(log(no_randomizations) ~ symbiosis + (1 | authors), data = dat)
summary(sa_random_symbiosis)
tidy(sa_random_symbiosis)
r2(sa_random_symbiosis)

sa_random_symbiosis1<-lmer(log(no_randomizations) ~ symbiosis - 1 + (1 | authors), data = dat)
summary(sa_random_symbiosis1)

sa_limit_symbiosis<-glmer(limit_rearched ~ symbiosis + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_symbiosis)
tidy(sa_limit_symbiosis)
r2(sa_limit_symbiosis)

sa_limit_symbiosis1<-glmer(limit_rearched ~ symbiosis - 1 + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_symbiosis1)


# host_tax_broad
sa_random_host_tax_broad<-glmer(log(no_randomizations) ~ host_tax_broad + (1 | authors), data = dat)
summary(sa_random_host_tax_broad)

sa_random_host_tax_broad1<-glmer(log(no_randomizations) ~ host_tax_broad - 1 + (1 | authors), data = dat)
summary(sa_random_host_tax_broad1)

sa_limit_host_tax_broad<-glmer(limit_rearched ~ host_tax_broad  + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_host_tax_broad)
r2(sa_limit_host_tax_broad)

sa_limit_host_tax_broad1<-glmer(limit_rearched ~ host_tax_broad - 1  + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_host_tax_broad1)


# mode_of_transmission_broad
sa_random_mode_of_transmission_broad<-glmer(log(no_randomizations) ~ mode_of_transmission_broad + (1 | authors), data = dat)
summary(sa_random_mode_of_transmission_broad)

sa_random_mode_of_transmission_broad1<-glmer(log(no_randomizations) ~ mode_of_transmission_broad - 1 + (1 | authors), data = dat)
summary(sa_random_mode_of_transmission_broad1)

sa_limit_mode_of_transmission_broad<-glmer(limit_rearched ~ mode_of_transmission_broad + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_mode_of_transmission_broad)

sa_limit_mode_of_transmission_broad1<-glmer(limit_rearched ~ mode_of_transmission_broad - 1 + (1 | authors), family = "binomial", data = dat)
summary(sa_limit_mode_of_transmission_broad1)

```


* adding AIC based stuff plus N??? + Year

### Recommendation
* they need to run more simuations so they do not max out!
* reanalysis of earlier trees are necessary; getting older or updated trees are required
* new studies should provide all data avaiable online so that future analysis can incorprate all avaiable data

## Acknowledgement

Much of coding materials have been borrowed from h

## Refererences

## Information for this R session

```{r}
sessionInfo() %>% pander()
```
